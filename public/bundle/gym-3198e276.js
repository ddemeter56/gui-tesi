
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { w as writable, S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, c as create_slot, v as validate_slots, j as element, x as attr_dev, k as add_location, e as insert_dev, u as update_slot, t as transition_in, f as transition_out, h as detach_dev, W as globals, P as validate_each_argument, A as validate_store, _ as te, B as component_subscribe, a as create_component, b as space, m as mount_component, g as destroy_component, l as text, o as append_dev, G as listen_dev, p as set_data_dev, I as binding_callbacks, J as bind, C as empty, D as group_outros, E as check_outros, T as destroy_each, M as select_multiple_value, n as noop, Q as add_render_callback, R as select_options, O as add_flush_callback, $ as is_function, a0 as run_all, Z as prop_dev, V as DropdownSingle, a1 as select_value, a2 as select_option, K as handle_promise } from './main-cc44d8d7.js';
import { p as postData, L as Label, I as Input } from './backendComm-59bbf3d3.js';
import { g as gymCodes } from './gymCodes-b58ecfcd.js';
import { n as notifyStore, W as Wizard, S as Step } from './Step-12f1b213.js';

function createGymStore() {
	const { subscribe } = writable(null);

	return {
    subscribe,
    submitForm: (oldForm) => postData('http://localhost/api/public/register/gym',convertForm(oldForm)).then((result) => {
      console.log(result);
      notifyStore.showNotify(result.error ? 'danger' : 'success',result.message);
    })
	};
}

const gymRegisterStore = createGymStore();

function convertForm(form){
  
  let newForm = {};
  let {facilityName,...rest} = form.openings[0];
  newForm.gym = form.gym;
  newForm.gymOpening = rest;
  newForm.gymPricing = form.pricing.filter(price => price.selectedFacility === 'generalPricing');
  
  newForm.facilities = form.facilities.map(item => {
      let {code,...rest} = item;
      let newItem = rest;
      newItem.code = code;
      return {facility : newItem};
  });

  
  newForm.facilities.map(item => { 

      item.ticketPricing = [];
      form.openings.map(open => {
          if((item.facility.name || item.facility.customName) === open.facilityName){
              let {facilityName,...rest} = open;
              item.opening = rest;
          }
      }); 
      form.pricing.map(price => {
          if((item.facility.name || item.facility.customName) === price.selectedFacility){
              let {selectedFacility,...rest} = price;
              item.ticketPricing.push(rest);
          }
      });
  });
  console.log(newForm);
  
  return newForm;
}

/* src\components\Text\Text.svelte generated by Svelte v3.29.7 */

const file = "src\\components\\Text\\Text.svelte";

function create_fragment(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", "textContainer");
			add_location(div, file, 7, 0, 39);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Text", slots, ['default']);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Text> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class Text extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Text",
			options,
			id: create_fragment.name
		});
	}
}

/* src\components\GymForm\Facilities.svelte generated by Svelte v3.29.7 */

const { console: console_1 } = globals;
const file$1 = "src\\components\\GymForm\\Facilities.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	child_ctx[12] = list;
	child_ctx[13] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (29:8) {#each facNameOptions.facilities as fac}
function create_each_block_1(ctx) {
	let option;
	let t_value = /*fac*/ ctx[11].name + "";
	let t;
	let option_value_value;

	const block = {
		c: function create() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*fac*/ ctx[11];
			option.value = option.__value;
			add_location(option, file$1, 29, 12, 834);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(29:8) {#each facNameOptions.facilities as fac}",
		ctx
	});

	return block;
}

// (27:0) <Label label={$_('gymRegister.gymFacilityStep.facilityList')}>
function create_default_slot_3(ctx) {
	let select;
	let mounted;
	let dispose;
	let each_value_1 = /*facNameOptions*/ ctx[4].facilities;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(select, "class", "allFacilityList svelte-1wvhhg9");
			select.multiple = true;
			if (/*facilityGeneralData*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[7].call(select));
			add_location(select, file$1, 27, 4, 696);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_options(select, /*facilityGeneralData*/ ctx[0]);

			if (!mounted) {
				dispose = listen_dev(select, "change", /*select_change_handler*/ ctx[7]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*facNameOptions*/ 16) {
				each_value_1 = /*facNameOptions*/ ctx[4].facilities;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (dirty & /*facilityGeneralData, facNameOptions*/ 17) {
				select_options(select, /*facilityGeneralData*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(27:0) <Label label={$_('gymRegister.gymFacilityStep.facilityList')}>",
		ctx
	});

	return block;
}

// (38:4) <Label label={`${$_('gymRegister.gymFacilityStep.descFor')} ${fac.name || fac.customName}`}>
function create_default_slot_2(ctx) {
	let input;
	let updating_value;
	let current;

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[8].call(null, value, /*fac*/ ctx[11]);
	}

	let input_props = { type: "C", length: 100 };

	if (/*fac*/ ctx[11].description !== void 0) {
		input_props.value = /*fac*/ ctx[11].description;
	}

	input = new Input({ props: input_props, $$inline: true });
	binding_callbacks.push(() => bind(input, "value", input_value_binding));

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const input_changes = {};

			if (!updating_value && dirty & /*facilityGeneralData*/ 1) {
				updating_value = true;
				input_changes.value = /*fac*/ ctx[11].description;
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(38:4) <Label label={`${$_('gymRegister.gymFacilityStep.descFor')} ${fac.name || fac.customName}`}>",
		ctx
	});

	return block;
}

// (37:0) {#each facilityGeneralData as fac}
function create_each_block(ctx) {
	let label;
	let t;
	let hr;
	let current;

	label = new Label({
			props: {
				label: `${/*$_*/ ctx[3]("gymRegister.gymFacilityStep.descFor")} ${/*fac*/ ctx[11].name || /*fac*/ ctx[11].customName}`,
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t = space();
			hr = element("hr");
			add_location(hr, file$1, 40, 4, 1149);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, hr, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};
			if (dirty & /*$_, facilityGeneralData*/ 9) label_changes.label = `${/*$_*/ ctx[3]("gymRegister.gymFacilityStep.descFor")} ${/*fac*/ ctx[11].name || /*fac*/ ctx[11].customName}`;

			if (dirty & /*$$scope, facilityGeneralData*/ 65537) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(hr);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(37:0) {#each facilityGeneralData as fac}",
		ctx
	});

	return block;
}

// (44:0) <Text>
function create_default_slot_1(ctx) {
	let t_value = /*$_*/ ctx[3]("gymRegister.gymFacilityStep.customFacilityDesc") + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$_*/ 8 && t_value !== (t_value = /*$_*/ ctx[3]("gymRegister.gymFacilityStep.customFacilityDesc") + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(44:0) <Text>",
		ctx
	});

	return block;
}

// (52:0) {#if showFacilityOther}
function create_if_block(ctx) {
	let label;
	let t0;
	let button;
	let t1_value = /*$_*/ ctx[3]("gymRegister.gymFacilityStep.addCustomFacilityButton") + "";
	let t1;
	let current;
	let mounted;
	let dispose;

	label = new Label({
			props: {
				label: /*$_*/ ctx[3]("gymRegister.gymFacilityStep.facilityName"),
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t0 = space();
			button = element("button");
			t1 = text(t1_value);
			add_location(button, file$1, 55, 4, 1567);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, button, anchor);
			append_dev(button, t1);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*addCustomFacility*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const label_changes = {};
			if (dirty & /*$_*/ 8) label_changes.label = /*$_*/ ctx[3]("gymRegister.gymFacilityStep.facilityName");

			if (dirty & /*$$scope, customName*/ 65540) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			if ((!current || dirty & /*$_*/ 8) && t1_value !== (t1_value = /*$_*/ ctx[3]("gymRegister.gymFacilityStep.addCustomFacilityButton") + "")) set_data_dev(t1, t1_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(52:0) {#if showFacilityOther}",
		ctx
	});

	return block;
}

// (53:4) <Label label={$_('gymRegister.gymFacilityStep.facilityName')}>
function create_default_slot(ctx) {
	let input;
	let updating_value;
	let current;

	function input_value_binding_1(value) {
		/*input_value_binding_1*/ ctx[10].call(null, value);
	}

	let input_props = { type: "C", length: 50 };

	if (/*customName*/ ctx[2] !== void 0) {
		input_props.value = /*customName*/ ctx[2];
	}

	input = new Input({ props: input_props, $$inline: true });
	binding_callbacks.push(() => bind(input, "value", input_value_binding_1));

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const input_changes = {};

			if (!updating_value && dirty & /*customName*/ 4) {
				updating_value = true;
				input_changes.value = /*customName*/ ctx[2];
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(53:4) <Label label={$_('gymRegister.gymFacilityStep.facilityName')}>",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let label;
	let t0;
	let hr0;
	let t1;
	let t2;
	let text_1;
	let t3;
	let hr1;
	let t4;
	let button;
	let t5_value = /*$_*/ ctx[3]("gymRegister.gymFacilityStep.customFacilityButton") + "";
	let t5;
	let t6;
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;

	label = new Label({
			props: {
				label: /*$_*/ ctx[3]("gymRegister.gymFacilityStep.facilityList"),
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let each_value = /*facilityGeneralData*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let if_block = /*showFacilityOther*/ ctx[1] && create_if_block(ctx);

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t0 = space();
			hr0 = element("hr");
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			create_component(text_1.$$.fragment);
			t3 = space();
			hr1 = element("hr");
			t4 = space();
			button = element("button");
			t5 = text(t5_value);
			t6 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			add_location(hr0, file$1, 34, 0, 919);
			add_location(hr1, file$1, 47, 0, 1246);
			add_location(button, file$1, 49, 0, 1256);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, hr0, anchor);
			insert_dev(target, t1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, t2, anchor);
			mount_component(text_1, target, anchor);
			insert_dev(target, t3, anchor);
			insert_dev(target, hr1, anchor);
			insert_dev(target, t4, anchor);
			insert_dev(target, button, anchor);
			append_dev(button, t5);
			insert_dev(target, t6, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[9], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const label_changes = {};
			if (dirty & /*$_*/ 8) label_changes.label = /*$_*/ ctx[3]("gymRegister.gymFacilityStep.facilityList");

			if (dirty & /*$$scope, facilityGeneralData*/ 65537) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);

			if (dirty & /*$_, facilityGeneralData*/ 9) {
				each_value = /*facilityGeneralData*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(t2.parentNode, t2);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			const text_1_changes = {};

			if (dirty & /*$$scope, $_*/ 65544) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
			if ((!current || dirty & /*$_*/ 8) && t5_value !== (t5_value = /*$_*/ ctx[3]("gymRegister.gymFacilityStep.customFacilityButton") + "")) set_data_dev(t5, t5_value);

			if (/*showFacilityOther*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*showFacilityOther*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(text_1.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(text_1.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(hr0);
			if (detaching) detach_dev(t1);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(text_1, detaching);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(hr1);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t6);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let $_;
	validate_store(te, "_");
	component_subscribe($$self, te, $$value => $$invalidate(3, $_ = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Facilities", slots, []);
	let { facilityGeneralData } = $$props;
	let { gymFacilityCols } = $$props;
	let facNameOptions = gymFacilityCols;
	let showFacilityOther = false;
	let customName;

	function addCustomFacility() {
		$$invalidate(0, facilityGeneralData = [...facilityGeneralData, { facility_cd: 1, customName }]);
	}

	const writable_props = ["facilityGeneralData", "gymFacilityCols"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Facilities> was created with unknown prop '${key}'`);
	});

	function select_change_handler() {
		facilityGeneralData = select_multiple_value(this);
		$$invalidate(0, facilityGeneralData);
		$$invalidate(4, facNameOptions);
	}

	function input_value_binding(value, fac) {
		fac.description = value;
		$$invalidate(0, facilityGeneralData);
	}

	const click_handler = () => {
		$$invalidate(1, showFacilityOther = !showFacilityOther);
	};

	function input_value_binding_1(value) {
		customName = value;
		$$invalidate(2, customName);
	}

	$$self.$$set = $$props => {
		if ("facilityGeneralData" in $$props) $$invalidate(0, facilityGeneralData = $$props.facilityGeneralData);
		if ("gymFacilityCols" in $$props) $$invalidate(6, gymFacilityCols = $$props.gymFacilityCols);
	};

	$$self.$capture_state = () => ({
		_: te,
		Label,
		Input,
		Text,
		facilityGeneralData,
		gymFacilityCols,
		facNameOptions,
		showFacilityOther,
		customName,
		addCustomFacility,
		$_
	});

	$$self.$inject_state = $$props => {
		if ("facilityGeneralData" in $$props) $$invalidate(0, facilityGeneralData = $$props.facilityGeneralData);
		if ("gymFacilityCols" in $$props) $$invalidate(6, gymFacilityCols = $$props.gymFacilityCols);
		if ("facNameOptions" in $$props) $$invalidate(4, facNameOptions = $$props.facNameOptions);
		if ("showFacilityOther" in $$props) $$invalidate(1, showFacilityOther = $$props.showFacilityOther);
		if ("customName" in $$props) $$invalidate(2, customName = $$props.customName);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*gymFacilityCols*/ 64) {
			 console.log(gymFacilityCols);
		}
	};

	return [
		facilityGeneralData,
		showFacilityOther,
		customName,
		$_,
		facNameOptions,
		addCustomFacility,
		gymFacilityCols,
		select_change_handler,
		input_value_binding,
		click_handler,
		input_value_binding_1
	];
}

class Facilities extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			facilityGeneralData: 0,
			gymFacilityCols: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Facilities",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*facilityGeneralData*/ ctx[0] === undefined && !("facilityGeneralData" in props)) {
			console_1.warn("<Facilities> was created without expected prop 'facilityGeneralData'");
		}

		if (/*gymFacilityCols*/ ctx[6] === undefined && !("gymFacilityCols" in props)) {
			console_1.warn("<Facilities> was created without expected prop 'gymFacilityCols'");
		}
	}

	get facilityGeneralData() {
		throw new Error("<Facilities>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set facilityGeneralData(value) {
		throw new Error("<Facilities>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get gymFacilityCols() {
		throw new Error("<Facilities>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set gymFacilityCols(value) {
		throw new Error("<Facilities>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\GymForm\General.svelte generated by Svelte v3.29.7 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	child_ctx[5] = list;
	child_ctx[6] = i;
	return child_ctx;
}

// (19:4) <Label required={item.required} label={$_(`gymRegister.gymBasicStep.${item.value}`)}>
function create_default_slot$1(ctx) {
	let input;
	let updating_value;
	let t;
	let current;

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[3].call(null, value, /*item*/ ctx[4]);
	}

	let input_props = {
		type: /*item*/ ctx[4].type,
		required: /*item*/ ctx[4].required,
		length: /*item*/ ctx[4].maxLength
	};

	if (/*gymGeneralData*/ ctx[0][/*item*/ ctx[4].value] !== void 0) {
		input_props.value = /*gymGeneralData*/ ctx[0][/*item*/ ctx[4].value];
	}

	input = new Input({ props: input_props, $$inline: true });
	binding_callbacks.push(() => bind(input, "value", input_value_binding));

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
			t = space();
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const input_changes = {};
			if (dirty & /*gymGeneralCols*/ 2) input_changes.type = /*item*/ ctx[4].type;
			if (dirty & /*gymGeneralCols*/ 2) input_changes.required = /*item*/ ctx[4].required;
			if (dirty & /*gymGeneralCols*/ 2) input_changes.length = /*item*/ ctx[4].maxLength;

			if (!updating_value && dirty & /*gymGeneralData, gymGeneralCols*/ 3) {
				updating_value = true;
				input_changes.value = /*gymGeneralData*/ ctx[0][/*item*/ ctx[4].value];
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(19:4) <Label required={item.required} label={$_(`gymRegister.gymBasicStep.${item.value}`)}>",
		ctx
	});

	return block;
}

// (18:0) {#each gymGeneralCols as item}
function create_each_block$1(ctx) {
	let label;
	let current;

	label = new Label({
			props: {
				required: /*item*/ ctx[4].required,
				label: /*$_*/ ctx[2](`gymRegister.gymBasicStep.${/*item*/ ctx[4].value}`),
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};
			if (dirty & /*gymGeneralCols*/ 2) label_changes.required = /*item*/ ctx[4].required;
			if (dirty & /*$_, gymGeneralCols*/ 6) label_changes.label = /*$_*/ ctx[2](`gymRegister.gymBasicStep.${/*item*/ ctx[4].value}`);

			if (dirty & /*$$scope, gymGeneralCols, gymGeneralData*/ 131) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(18:0) {#each gymGeneralCols as item}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*gymGeneralCols*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*gymGeneralCols, $_, gymGeneralData*/ 7) {
				each_value = /*gymGeneralCols*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let $_;
	validate_store(te, "_");
	component_subscribe($$self, te, $$value => $$invalidate(2, $_ = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("General", slots, []);
	let { gymGeneralData } = $$props;
	let { gymGeneralCols } = $$props;

	// Langauge-t bongeszobol kene allitani?
	gymGeneralData.languageCode = "hu";

	const writable_props = ["gymGeneralData", "gymGeneralCols"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<General> was created with unknown prop '${key}'`);
	});

	function input_value_binding(value, item) {
		gymGeneralData[item.value] = value;
		$$invalidate(0, gymGeneralData);
	}

	$$self.$$set = $$props => {
		if ("gymGeneralData" in $$props) $$invalidate(0, gymGeneralData = $$props.gymGeneralData);
		if ("gymGeneralCols" in $$props) $$invalidate(1, gymGeneralCols = $$props.gymGeneralCols);
	};

	$$self.$capture_state = () => ({
		_: te,
		Label,
		Input,
		gymGeneralData,
		gymGeneralCols,
		$_
	});

	$$self.$inject_state = $$props => {
		if ("gymGeneralData" in $$props) $$invalidate(0, gymGeneralData = $$props.gymGeneralData);
		if ("gymGeneralCols" in $$props) $$invalidate(1, gymGeneralCols = $$props.gymGeneralCols);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [gymGeneralData, gymGeneralCols, $_, input_value_binding];
}

class General extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { gymGeneralData: 0, gymGeneralCols: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "General",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*gymGeneralData*/ ctx[0] === undefined && !("gymGeneralData" in props)) {
			console.warn("<General> was created without expected prop 'gymGeneralData'");
		}

		if (/*gymGeneralCols*/ ctx[1] === undefined && !("gymGeneralCols" in props)) {
			console.warn("<General> was created without expected prop 'gymGeneralCols'");
		}
	}

	get gymGeneralData() {
		throw new Error("<General>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set gymGeneralData(value) {
		throw new Error("<General>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get gymGeneralCols() {
		throw new Error("<General>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set gymGeneralCols(value) {
		throw new Error("<General>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\GymForm\Opening.svelte generated by Svelte v3.29.7 */
const file$2 = "src\\components\\GymForm\\Opening.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[18] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[19] = list[i];
	child_ctx[20] = list;
	child_ctx[21] = i;
	return child_ctx;
}

// (101:16) {#each openingGeneralData as row}
function create_each_block_2(ctx) {
	let td;
	let div;
	let input;
	let input_style_value;
	let input_maxlength_value;
	let input_disabled_value;
	let input_value_value;
	let mounted;
	let dispose;

	function input_handler(...args) {
		return /*input_handler*/ ctx[10](/*row*/ ctx[19], /*c*/ ctx[16], /*each_value_2*/ ctx[20], /*row_index*/ ctx[21], ...args);
	}

	const block = {
		c: function create() {
			td = element("td");
			div = element("div");
			input = element("input");

			attr_dev(input, "style", input_style_value = /*c*/ ctx[16].value === "facilityName"
			? " background-color: rgb(199, 199, 199);  color:maroon; font-weight:800; cursor:not-allowed;"
			: "");

			attr_dev(input, "type", "text");
			attr_dev(input, "maxlength", input_maxlength_value = /*c*/ ctx[16].maxLength);
			input.disabled = input_disabled_value = /*c*/ ctx[16].value === "facilityName";
			input.value = input_value_value = /*row*/ ctx[19][/*c*/ ctx[16].value];
			add_location(input, file$2, 103, 28, 4738);
			attr_dev(div, "class", "tdInputStyle svelte-1dc7ui1");
			add_location(div, file$2, 102, 24, 4682);
			attr_dev(td, "class", "svelte-1dc7ui1");
			add_location(td, file$2, 101, 20, 4652);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, div);
			append_dev(div, input);

			if (!mounted) {
				dispose = listen_dev(input, "input", input_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*openingInfos*/ 4 && input_style_value !== (input_style_value = /*c*/ ctx[16].value === "facilityName"
			? " background-color: rgb(199, 199, 199);  color:maroon; font-weight:800; cursor:not-allowed;"
			: "")) {
				attr_dev(input, "style", input_style_value);
			}

			if (dirty & /*openingInfos*/ 4 && input_maxlength_value !== (input_maxlength_value = /*c*/ ctx[16].maxLength)) {
				attr_dev(input, "maxlength", input_maxlength_value);
			}

			if (dirty & /*openingInfos*/ 4 && input_disabled_value !== (input_disabled_value = /*c*/ ctx[16].value === "facilityName")) {
				prop_dev(input, "disabled", input_disabled_value);
			}

			if (dirty & /*openingGeneralData, openingInfos*/ 5 && input_value_value !== (input_value_value = /*row*/ ctx[19][/*c*/ ctx[16].value]) && input.value !== input_value_value) {
				prop_dev(input, "value", input_value_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(101:16) {#each openingGeneralData as row}",
		ctx
	});

	return block;
}

// (98:8) {#each openingInfos.openingHoursForm as c, i}
function create_each_block_1$1(ctx) {
	let tr;
	let th;
	let t0_value = /*$_*/ ctx[5](`gymRegister.gymOpeningStep.${/*c*/ ctx[16].value}`) + "";
	let t0;
	let t1;
	let t2;
	let each_value_2 = /*openingGeneralData*/ ctx[0];
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");
			th = element("th");
			t0 = text(t0_value);
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			attr_dev(th, "class", "svelte-1dc7ui1");
			add_location(th, file$2, 99, 16, 4525);
			attr_dev(tr, "class", "svelte-1dc7ui1");
			add_location(tr, file$2, 98, 12, 4503);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, th);
			append_dev(th, t0);
			append_dev(tr, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$_, openingInfos*/ 36 && t0_value !== (t0_value = /*$_*/ ctx[5](`gymRegister.gymOpeningStep.${/*c*/ ctx[16].value}`) + "")) set_data_dev(t0, t0_value);

			if (dirty & /*openingInfos, openingGeneralData*/ 5) {
				each_value_2 = /*openingGeneralData*/ ctx[0];
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t2);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$1.name,
		type: "each",
		source: "(98:8) {#each openingInfos.openingHoursForm as c, i}",
		ctx
	});

	return block;
}

// (116:12) <Text>
function create_default_slot$2(ctx) {
	let t_value = (/*fac*/ ctx[13].name || /*fac*/ ctx[13].customName) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*facilities*/ 2 && t_value !== (t_value = (/*fac*/ ctx[13].name || /*fac*/ ctx[13].customName) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(116:12) <Text>",
		ctx
	});

	return block;
}

// (114:4) {#each facilities as fac}
function create_each_block$2(ctx) {
	let li;
	let text_1;
	let t0;
	let button0;
	let t1_value = /*$_*/ ctx[5]("gymRegister.gymOpeningStep.openAddFacility") + "";
	let t1;
	let t2;
	let button1;
	let t3_value = /*$_*/ ctx[5]("gymRegister.gymOpeningStep.openDeleteFacility") + "";
	let t3;
	let t4;
	let current;
	let mounted;
	let dispose;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			li = element("li");
			create_component(text_1.$$.fragment);
			t0 = space();
			button0 = element("button");
			t1 = text(t1_value);
			t2 = space();
			button1 = element("button");
			t3 = text(t3_value);
			t4 = space();
			add_location(li, file$2, 114, 8, 5215);
			add_location(button0, file$2, 119, 8, 5331);
			add_location(button1, file$2, 122, 8, 5460);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(text_1, li, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, button0, anchor);
			append_dev(button0, t1);
			insert_dev(target, t2, anchor);
			insert_dev(target, button1, anchor);
			append_dev(button1, t3);
			append_dev(button1, t4);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(
						button0,
						"click",
						function () {
							if (is_function(/*addFacility*/ ctx[7](/*fac*/ ctx[13]))) /*addFacility*/ ctx[7](/*fac*/ ctx[13]).apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(
						button1,
						"click",
						function () {
							if (is_function(/*deleteFacility*/ ctx[6](/*fac*/ ctx[13]))) /*deleteFacility*/ ctx[6](/*fac*/ ctx[13]).apply(this, arguments);
						},
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const text_1_changes = {};

			if (dirty & /*$$scope, facilities*/ 4194306) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
			if ((!current || dirty & /*$_*/ 32) && t1_value !== (t1_value = /*$_*/ ctx[5]("gymRegister.gymOpeningStep.openAddFacility") + "")) set_data_dev(t1, t1_value);
			if ((!current || dirty & /*$_*/ 32) && t3_value !== (t3_value = /*$_*/ ctx[5]("gymRegister.gymOpeningStep.openDeleteFacility") + "")) set_data_dev(t3, t3_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_component(text_1);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(button0);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(button1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(114:4) {#each facilities as fac}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div;
	let table;
	let t0;
	let ul;
	let t1;
	let hr0;
	let t2;
	let input0;
	let updating_value;
	let t3;
	let input1;
	let updating_value_1;
	let t4;
	let button0;
	let t5_value = /*$_*/ ctx[5]("gymRegister.gymOpeningStep.alignTimes") + "";
	let t5;
	let t6;
	let hr1;
	let t7;
	let button1;
	let t8_value = /*$_*/ ctx[5]("gymRegister.gymOpeningStep.deleteAll") + "";
	let t8;
	let t9;
	let hr2;
	let current;
	let mounted;
	let dispose;
	let each_value_1 = /*openingInfos*/ ctx[2].openingHoursForm;
	validate_each_argument(each_value_1);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	let each_value = /*facilities*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	function input0_value_binding(value) {
		/*input0_value_binding*/ ctx[11].call(null, value);
	}

	let input0_props = { type: "T" };

	if (/*defaultOpening*/ ctx[3] !== void 0) {
		input0_props.value = /*defaultOpening*/ ctx[3];
	}

	input0 = new Input({ props: input0_props, $$inline: true });
	binding_callbacks.push(() => bind(input0, "value", input0_value_binding));

	function input1_value_binding(value) {
		/*input1_value_binding*/ ctx[12].call(null, value);
	}

	let input1_props = { type: "T" };

	if (/*defaultClosing*/ ctx[4] !== void 0) {
		input1_props.value = /*defaultClosing*/ ctx[4];
	}

	input1 = new Input({ props: input1_props, $$inline: true });
	binding_callbacks.push(() => bind(input1, "value", input1_value_binding));

	const block = {
		c: function create() {
			div = element("div");
			table = element("table");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t0 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			hr0 = element("hr");
			t2 = space();
			create_component(input0.$$.fragment);
			t3 = space();
			create_component(input1.$$.fragment);
			t4 = space();
			button0 = element("button");
			t5 = text(t5_value);
			t6 = space();
			hr1 = element("hr");
			t7 = space();
			button1 = element("button");
			t8 = text(t8_value);
			t9 = space();
			hr2 = element("hr");
			add_location(table, file$2, 96, 4, 4427);
			attr_dev(div, "class", "tableContainer svelte-1dc7ui1");
			add_location(div, file$2, 95, 0, 4393);
			add_location(ul, file$2, 112, 0, 5170);
			add_location(hr0, file$2, 128, 0, 5609);
			add_location(button0, file$2, 134, 0, 5723);
			add_location(hr1, file$2, 135, 0, 5808);
			add_location(button1, file$2, 136, 0, 5816);
			add_location(hr2, file$2, 137, 0, 5900);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, table);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(table, null);
			}

			insert_dev(target, t0, anchor);
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			insert_dev(target, t1, anchor);
			insert_dev(target, hr0, anchor);
			insert_dev(target, t2, anchor);
			mount_component(input0, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(input1, target, anchor);
			insert_dev(target, t4, anchor);
			insert_dev(target, button0, anchor);
			append_dev(button0, t5);
			insert_dev(target, t6, anchor);
			insert_dev(target, hr1, anchor);
			insert_dev(target, t7, anchor);
			insert_dev(target, button1, anchor);
			append_dev(button1, t8);
			insert_dev(target, t9, anchor);
			insert_dev(target, hr2, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*fillTimes*/ ctx[8], false, false, false),
					listen_dev(button1, "click", /*deleteAll*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*openingGeneralData, openingInfos, $_*/ 37) {
				each_value_1 = /*openingInfos*/ ctx[2].openingHoursForm;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1$1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(table, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty & /*deleteFacility, facilities, $_, addFacility*/ 226) {
				each_value = /*facilities*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			const input0_changes = {};

			if (!updating_value && dirty & /*defaultOpening*/ 8) {
				updating_value = true;
				input0_changes.value = /*defaultOpening*/ ctx[3];
				add_flush_callback(() => updating_value = false);
			}

			input0.$set(input0_changes);
			const input1_changes = {};

			if (!updating_value_1 && dirty & /*defaultClosing*/ 16) {
				updating_value_1 = true;
				input1_changes.value = /*defaultClosing*/ ctx[4];
				add_flush_callback(() => updating_value_1 = false);
			}

			input1.$set(input1_changes);
			if ((!current || dirty & /*$_*/ 32) && t5_value !== (t5_value = /*$_*/ ctx[5]("gymRegister.gymOpeningStep.alignTimes") + "")) set_data_dev(t5, t5_value);
			if ((!current || dirty & /*$_*/ 32) && t8_value !== (t8_value = /*$_*/ ctx[5]("gymRegister.gymOpeningStep.deleteAll") + "")) set_data_dev(t8, t8_value);
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(input0.$$.fragment, local);
			transition_in(input1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(input0.$$.fragment, local);
			transition_out(input1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks_1, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(hr0);
			if (detaching) detach_dev(t2);
			destroy_component(input0, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(input1, detaching);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(button0);
			if (detaching) detach_dev(t6);
			if (detaching) detach_dev(hr1);
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(button1);
			if (detaching) detach_dev(t9);
			if (detaching) detach_dev(hr2);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let $_;
	validate_store(te, "_");
	component_subscribe($$self, te, $$value => $$invalidate(5, $_ = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Opening", slots, []);
	let { openingGeneralData } = $$props;
	let { facilities } = $$props;
	let { openingInfos } = $$props;
	let defaultOpening = "08:00";
	let defaultClosing = "22:00";

	function deleteFacility(fac) {
		$$invalidate(0, openingGeneralData = openingGeneralData.filter(open => open.facilityName !== fac.name));
	}

	function addFacility(fac) {
		let filter = openingGeneralData.filter(open => open.facilityName === fac.name || open.facilityName === fac.customName);

		if (filter.length === 0) {
			$$invalidate(0, openingGeneralData = [
				...openingGeneralData,
				{
					facilityName: fac.name ? fac.name : fac.customName,
					mondayFrom: "",
					mondayTo: "",
					tuesdayFrom: "",
					tuesdayTo: "",
					wednesdayFrom: "",
					wednesdayTo: "",
					thursdayFrom: "",
					thursdayTo: "",
					fridayFrom: "",
					fridayTo: "",
					saturdayFrom: "",
					saturdayTo: "",
					sundayFrom: "",
					sundayTo: ""
				}
			]);
		}
	}

	function fillTimes() {
		$$invalidate(0, openingGeneralData = openingGeneralData.reduce(
			(acc, curr) => {
				for (let key in curr) {
					if (key.includes("To")) {
						curr[key] = defaultClosing;
					}

					if (key.includes("From")) {
						curr[key] = defaultOpening;
					}
				}

				return [...acc, curr];
			},
			[]
		));
	}

	function deleteAll() {
		$$invalidate(0, openingGeneralData = [
			{
				facilityName: $_("gymRegister.gymOpeningStep.generalOpening"),
				fridayFrom: "",
				fridayTo: "",
				mondayFrom: "",
				mondayTo: "",
				saturdayFrom: "",
				saturdayTo: "",
				sundayFrom: "",
				sundayTo: "",
				thursdayFrom: "",
				thursdayTo: "",
				tuesdayFrom: "",
				tuesdayTo: "",
				wednesdayFrom: "",
				wednesdayTo: ""
			}
		]);
	}

	const writable_props = ["openingGeneralData", "facilities", "openingInfos"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Opening> was created with unknown prop '${key}'`);
	});

	const input_handler = (row, c, each_value_2, row_index, e) => $$invalidate(0, each_value_2[row_index][c.value] = e.target.value, openingGeneralData);

	function input0_value_binding(value) {
		defaultOpening = value;
		$$invalidate(3, defaultOpening);
	}

	function input1_value_binding(value) {
		defaultClosing = value;
		$$invalidate(4, defaultClosing);
	}

	$$self.$$set = $$props => {
		if ("openingGeneralData" in $$props) $$invalidate(0, openingGeneralData = $$props.openingGeneralData);
		if ("facilities" in $$props) $$invalidate(1, facilities = $$props.facilities);
		if ("openingInfos" in $$props) $$invalidate(2, openingInfos = $$props.openingInfos);
	};

	$$self.$capture_state = () => ({
		_: te,
		Input,
		Text,
		openingGeneralData,
		facilities,
		openingInfos,
		defaultOpening,
		defaultClosing,
		deleteFacility,
		addFacility,
		fillTimes,
		deleteAll,
		$_
	});

	$$self.$inject_state = $$props => {
		if ("openingGeneralData" in $$props) $$invalidate(0, openingGeneralData = $$props.openingGeneralData);
		if ("facilities" in $$props) $$invalidate(1, facilities = $$props.facilities);
		if ("openingInfos" in $$props) $$invalidate(2, openingInfos = $$props.openingInfos);
		if ("defaultOpening" in $$props) $$invalidate(3, defaultOpening = $$props.defaultOpening);
		if ("defaultClosing" in $$props) $$invalidate(4, defaultClosing = $$props.defaultClosing);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*openingGeneralData, $_*/ 33) {
			 if (openingGeneralData.length === 0) {
				$$invalidate(0, openingGeneralData = [
					{
						facilityName: $_("gymRegister.gymOpeningStep.generalOpening"),
						fridayFrom: "",
						fridayTo: "",
						mondayFrom: "",
						mondayTo: "",
						saturdayFrom: "",
						saturdayTo: "",
						sundayFrom: "",
						sundayTo: "",
						thursdayFrom: "",
						thursdayTo: "",
						tuesdayFrom: "",
						tuesdayTo: "",
						wednesdayFrom: "",
						wednesdayTo: ""
					}
				]);
			}
		}
	};

	return [
		openingGeneralData,
		facilities,
		openingInfos,
		defaultOpening,
		defaultClosing,
		$_,
		deleteFacility,
		addFacility,
		fillTimes,
		deleteAll,
		input_handler,
		input0_value_binding,
		input1_value_binding
	];
}

class Opening extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			openingGeneralData: 0,
			facilities: 1,
			openingInfos: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Opening",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*openingGeneralData*/ ctx[0] === undefined && !("openingGeneralData" in props)) {
			console.warn("<Opening> was created without expected prop 'openingGeneralData'");
		}

		if (/*facilities*/ ctx[1] === undefined && !("facilities" in props)) {
			console.warn("<Opening> was created without expected prop 'facilities'");
		}

		if (/*openingInfos*/ ctx[2] === undefined && !("openingInfos" in props)) {
			console.warn("<Opening> was created without expected prop 'openingInfos'");
		}
	}

	get openingGeneralData() {
		throw new Error("<Opening>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set openingGeneralData(value) {
		throw new Error("<Opening>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get facilities() {
		throw new Error("<Opening>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set facilities(value) {
		throw new Error("<Opening>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get openingInfos() {
		throw new Error("<Opening>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set openingInfos(value) {
		throw new Error("<Opening>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\GymForm\Pricing.svelte generated by Svelte v3.29.7 */

const { console: console_1$1 } = globals;
const file$3 = "src\\components\\GymForm\\Pricing.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	return child_ctx;
}

function get_each_context_1$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[18] = list[i];
	return child_ctx;
}

function get_each_context_2$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[18] = list[i];
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i].name;
	child_ctx[24] = list[i].customName;
	return child_ctx;
}

// (70:4) {#each selectedFacilities as { name, customName }}
function create_each_block_3(ctx) {
	let option;
	let t_value = (/*name*/ ctx[23] || /*customName*/ ctx[24]) + "";
	let t;
	let option_value_value;

	const block = {
		c: function create() {
			option = element("option");
			t = text(t_value);

			option.__value = option_value_value = /*name*/ ctx[23]
			? /*name*/ ctx[23]
			: /*customName*/ ctx[24];

			option.value = option.__value;
			add_location(option, file$3, 70, 6, 2488);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selectedFacilities*/ 2 && t_value !== (t_value = (/*name*/ ctx[23] || /*customName*/ ctx[24]) + "")) set_data_dev(t, t_value);

			if (dirty & /*selectedFacilities*/ 2 && option_value_value !== (option_value_value = /*name*/ ctx[23]
			? /*name*/ ctx[23]
			: /*customName*/ ctx[24])) {
				prop_dev(option, "__value", option_value_value);
				option.value = option.__value;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3.name,
		type: "each",
		source: "(70:4) {#each selectedFacilities as { name, customName }}",
		ctx
	});

	return block;
}

// (67:0) <Label label={$_('gymRegister.gymPricing.selectedFacility')}>
function create_default_slot_5(ctx) {
	let select;
	let option;
	let t_value = /*$_*/ ctx[4]("gymRegister.gymPricing.generalPricing") + "";
	let t;
	let option_value_value;
	let mounted;
	let dispose;
	let each_value_3 = /*selectedFacilities*/ ctx[1];
	validate_each_argument(each_value_3);
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	const block = {
		c: function create() {
			select = element("select");
			option = element("option");
			t = text(t_value);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			option.__value = option_value_value = "generalPricing";
			option.value = option.__value;
			add_location(option, file$3, 68, 4, 2337);
			if (/*actPrice*/ ctx[2].selectedFacility === void 0) add_render_callback(() => /*select_change_handler*/ ctx[9].call(select));
			add_location(select, file$3, 67, 2, 2284);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);
			append_dev(select, option);
			append_dev(option, t);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*actPrice*/ ctx[2].selectedFacility);

			if (!mounted) {
				dispose = listen_dev(select, "change", /*select_change_handler*/ ctx[9]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$_*/ 16 && t_value !== (t_value = /*$_*/ ctx[4]("gymRegister.gymPricing.generalPricing") + "")) set_data_dev(t, t_value);

			if (dirty & /*selectedFacilities*/ 2) {
				each_value_3 = /*selectedFacilities*/ ctx[1];
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_3.length;
			}

			if (dirty & /*actPrice, selectedFacilities*/ 6) {
				select_option(select, /*actPrice*/ ctx[2].selectedFacility);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(67:0) <Label label={$_('gymRegister.gymPricing.selectedFacility')}>",
		ctx
	});

	return block;
}

// (76:0) <Label label={$_('gymRegister.gymPricing.categoryType')}>
function create_default_slot_4(ctx) {
	let dropdown;
	let updating_selected;
	let current;

	function dropdown_selected_binding(value) {
		/*dropdown_selected_binding*/ ctx[10].call(null, value);
	}

	let dropdown_props = { items: /*categories*/ ctx[5] };

	if (/*actPrice*/ ctx[2].categoryType !== void 0) {
		dropdown_props.selected = /*actPrice*/ ctx[2].categoryType;
	}

	dropdown = new DropdownSingle({ props: dropdown_props, $$inline: true });
	binding_callbacks.push(() => bind(dropdown, "selected", dropdown_selected_binding));

	const block = {
		c: function create() {
			create_component(dropdown.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(dropdown, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const dropdown_changes = {};
			if (dirty & /*categories*/ 32) dropdown_changes.items = /*categories*/ ctx[5];

			if (!updating_selected && dirty & /*actPrice*/ 4) {
				updating_selected = true;
				dropdown_changes.selected = /*actPrice*/ ctx[2].categoryType;
				add_flush_callback(() => updating_selected = false);
			}

			dropdown.$set(dropdown_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dropdown.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dropdown.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(dropdown, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(76:0) <Label label={$_('gymRegister.gymPricing.categoryType')}>",
		ctx
	});

	return block;
}

// (80:0) <Label label={$_('gymRegister.gymPricing.ticketType')}>
function create_default_slot_3$1(ctx) {
	let input;
	let updating_value;
	let current;

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[11].call(null, value);
	}

	let input_props = { type: "C" };

	if (/*actPrice*/ ctx[2].ticketType !== void 0) {
		input_props.value = /*actPrice*/ ctx[2].ticketType;
	}

	input = new Input({ props: input_props, $$inline: true });
	binding_callbacks.push(() => bind(input, "value", input_value_binding));

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const input_changes = {};

			if (!updating_value && dirty & /*actPrice*/ 4) {
				updating_value = true;
				input_changes.value = /*actPrice*/ ctx[2].ticketType;
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(80:0) <Label label={$_('gymRegister.gymPricing.ticketType')}>",
		ctx
	});

	return block;
}

// (84:0) <Label label={$_('gymRegister.gymPricing.amount')}>
function create_default_slot_2$1(ctx) {
	let input;
	let updating_value;
	let current;

	function input_value_binding_1(value) {
		/*input_value_binding_1*/ ctx[12].call(null, value);
	}

	let input_props = { type: "N" };

	if (/*actPrice*/ ctx[2].amount !== void 0) {
		input_props.value = /*actPrice*/ ctx[2].amount;
	}

	input = new Input({ props: input_props, $$inline: true });
	binding_callbacks.push(() => bind(input, "value", input_value_binding_1));

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const input_changes = {};

			if (!updating_value && dirty & /*actPrice*/ 4) {
				updating_value = true;
				input_changes.value = /*actPrice*/ ctx[2].amount;
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(84:0) <Label label={$_('gymRegister.gymPricing.amount')}>",
		ctx
	});

	return block;
}

// (88:0) <Label label={$_('gymRegister.gymPricing.currency')}>
function create_default_slot_1$1(ctx) {
	let input;
	let updating_value;
	let current;

	function input_value_binding_2(value) {
		/*input_value_binding_2*/ ctx[13].call(null, value);
	}

	let input_props = { type: "C" };

	if (/*actPrice*/ ctx[2].currency !== void 0) {
		input_props.value = /*actPrice*/ ctx[2].currency;
	}

	input = new Input({ props: input_props, $$inline: true });
	binding_callbacks.push(() => bind(input, "value", input_value_binding_2));

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const input_changes = {};

			if (!updating_value && dirty & /*actPrice*/ 4) {
				updating_value = true;
				input_changes.value = /*actPrice*/ ctx[2].currency;
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(88:0) <Label label={$_('gymRegister.gymPricing.currency')}>",
		ctx
	});

	return block;
}

// (92:0) <Label label={$_('gymRegister.gymPricing.validForDays')}>
function create_default_slot$3(ctx) {
	let input;
	let updating_value;
	let current;

	function input_value_binding_3(value) {
		/*input_value_binding_3*/ ctx[14].call(null, value);
	}

	let input_props = { type: "N" };

	if (/*actPrice*/ ctx[2].validForDays !== void 0) {
		input_props.value = /*actPrice*/ ctx[2].validForDays;
	}

	input = new Input({ props: input_props, $$inline: true });
	binding_callbacks.push(() => bind(input, "value", input_value_binding_3));

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const input_changes = {};

			if (!updating_value && dirty & /*actPrice*/ 4) {
				updating_value = true;
				input_changes.value = /*actPrice*/ ctx[2].validForDays;
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(92:0) <Label label={$_('gymRegister.gymPricing.validForDays')}>",
		ctx
	});

	return block;
}

// (101:4) {#each tableHeaders as header}
function create_each_block_2$1(ctx) {
	let th;
	let t0_value = /*header*/ ctx[18].label + "";
	let t0;
	let t1;

	const block = {
		c: function create() {
			th = element("th");
			t0 = text(t0_value);
			t1 = space();
			attr_dev(th, "class", "svelte-ntkw10");
			add_location(th, file$3, 101, 6, 3431);
		},
		m: function mount(target, anchor) {
			insert_dev(target, th, anchor);
			append_dev(th, t0);
			append_dev(th, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*tableHeaders*/ 8 && t0_value !== (t0_value = /*header*/ ctx[18].label + "")) set_data_dev(t0, t0_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(th);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2$1.name,
		type: "each",
		source: "(101:4) {#each tableHeaders as header}",
		ctx
	});

	return block;
}

// (109:6) {#each tableHeaders as header}
function create_each_block_1$2(ctx) {
	let td;
	let t_value = /*fillTableData*/ ctx[7](/*price*/ ctx[15], /*header*/ ctx[18]) + "";
	let t;

	const block = {
		c: function create() {
			td = element("td");
			t = text(t_value);
			attr_dev(td, "class", "svelte-ntkw10");
			add_location(td, file$3, 109, 8, 3591);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*pricingGeneralData, tableHeaders*/ 9 && t_value !== (t_value = /*fillTableData*/ ctx[7](/*price*/ ctx[15], /*header*/ ctx[18]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$2.name,
		type: "each",
		source: "(109:6) {#each tableHeaders as header}",
		ctx
	});

	return block;
}

// (107:2) {#each pricingGeneralData as price}
function create_each_block$3(ctx) {
	let tr;
	let t0;
	let span;
	let t2;
	let mounted;
	let dispose;
	let each_value_1 = /*tableHeaders*/ ctx[3];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			span = element("span");
			span.textContent = "";
			t2 = space();
			attr_dev(span, "class", "closingMark svelte-ntkw10");
			add_location(span, file$3, 111, 6, 3652);
			attr_dev(tr, "class", "svelte-ntkw10");
			add_location(tr, file$3, 107, 4, 3539);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t0);
			append_dev(tr, span);
			append_dev(tr, t2);

			if (!mounted) {
				dispose = listen_dev(
					span,
					"click",
					function () {
						if (is_function(/*deleteFromPricing*/ ctx[8](/*price*/ ctx[15]))) /*deleteFromPricing*/ ctx[8](/*price*/ ctx[15]).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*fillTableData, pricingGeneralData, tableHeaders*/ 137) {
				each_value_1 = /*tableHeaders*/ ctx[3];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t0);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(107:2) {#each pricingGeneralData as price}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let label0;
	let t0;
	let label1;
	let t1;
	let hr0;
	let t2;
	let label2;
	let t3;
	let hr1;
	let t4;
	let label3;
	let t5;
	let hr2;
	let t6;
	let label4;
	let t7;
	let hr3;
	let t8;
	let label5;
	let t9;
	let button;
	let t10_value = /*$_*/ ctx[4]("gymRegister.gymPricing.addToList") + "";
	let t10;
	let t11;
	let hr4;
	let t12;
	let table;
	let tr;
	let t13;
	let current;
	let mounted;
	let dispose;

	label0 = new Label({
			props: {
				label: /*$_*/ ctx[4]("gymRegister.gymPricing.selectedFacility"),
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label1 = new Label({
			props: {
				label: /*$_*/ ctx[4]("gymRegister.gymPricing.categoryType"),
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label2 = new Label({
			props: {
				label: /*$_*/ ctx[4]("gymRegister.gymPricing.ticketType"),
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label3 = new Label({
			props: {
				label: /*$_*/ ctx[4]("gymRegister.gymPricing.amount"),
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label4 = new Label({
			props: {
				label: /*$_*/ ctx[4]("gymRegister.gymPricing.currency"),
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label5 = new Label({
			props: {
				label: /*$_*/ ctx[4]("gymRegister.gymPricing.validForDays"),
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let each_value_2 = /*tableHeaders*/ ctx[3];
	validate_each_argument(each_value_2);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_1[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
	}

	let each_value = /*pricingGeneralData*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			create_component(label0.$$.fragment);
			t0 = space();
			create_component(label1.$$.fragment);
			t1 = space();
			hr0 = element("hr");
			t2 = space();
			create_component(label2.$$.fragment);
			t3 = space();
			hr1 = element("hr");
			t4 = space();
			create_component(label3.$$.fragment);
			t5 = space();
			hr2 = element("hr");
			t6 = space();
			create_component(label4.$$.fragment);
			t7 = space();
			hr3 = element("hr");
			t8 = space();
			create_component(label5.$$.fragment);
			t9 = space();
			button = element("button");
			t10 = text(t10_value);
			t11 = space();
			hr4 = element("hr");
			t12 = space();
			table = element("table");
			tr = element("tr");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t13 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			add_location(hr0, file$3, 78, 0, 2740);
			add_location(hr1, file$3, 82, 0, 2870);
			add_location(hr2, file$3, 86, 0, 2993);
			add_location(hr3, file$3, 90, 0, 3119);
			add_location(button, file$3, 95, 0, 3255);
			add_location(hr4, file$3, 97, 0, 3341);
			attr_dev(tr, "class", "svelte-ntkw10");
			add_location(tr, file$3, 99, 2, 3383);
			attr_dev(table, "class", "tableContainer svelte-ntkw10");
			add_location(table, file$3, 98, 0, 3349);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(label0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(label1, target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, hr0, anchor);
			insert_dev(target, t2, anchor);
			mount_component(label2, target, anchor);
			insert_dev(target, t3, anchor);
			insert_dev(target, hr1, anchor);
			insert_dev(target, t4, anchor);
			mount_component(label3, target, anchor);
			insert_dev(target, t5, anchor);
			insert_dev(target, hr2, anchor);
			insert_dev(target, t6, anchor);
			mount_component(label4, target, anchor);
			insert_dev(target, t7, anchor);
			insert_dev(target, hr3, anchor);
			insert_dev(target, t8, anchor);
			mount_component(label5, target, anchor);
			insert_dev(target, t9, anchor);
			insert_dev(target, button, anchor);
			append_dev(button, t10);
			insert_dev(target, t11, anchor);
			insert_dev(target, hr4, anchor);
			insert_dev(target, t12, anchor);
			insert_dev(target, table, anchor);
			append_dev(table, tr);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(tr, null);
			}

			append_dev(table, t13);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(table, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*addToPricing*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const label0_changes = {};
			if (dirty & /*$_*/ 16) label0_changes.label = /*$_*/ ctx[4]("gymRegister.gymPricing.selectedFacility");

			if (dirty & /*$$scope, actPrice, selectedFacilities, $_*/ 134217750) {
				label0_changes.$$scope = { dirty, ctx };
			}

			label0.$set(label0_changes);
			const label1_changes = {};
			if (dirty & /*$_*/ 16) label1_changes.label = /*$_*/ ctx[4]("gymRegister.gymPricing.categoryType");

			if (dirty & /*$$scope, categories, actPrice*/ 134217764) {
				label1_changes.$$scope = { dirty, ctx };
			}

			label1.$set(label1_changes);
			const label2_changes = {};
			if (dirty & /*$_*/ 16) label2_changes.label = /*$_*/ ctx[4]("gymRegister.gymPricing.ticketType");

			if (dirty & /*$$scope, actPrice*/ 134217732) {
				label2_changes.$$scope = { dirty, ctx };
			}

			label2.$set(label2_changes);
			const label3_changes = {};
			if (dirty & /*$_*/ 16) label3_changes.label = /*$_*/ ctx[4]("gymRegister.gymPricing.amount");

			if (dirty & /*$$scope, actPrice*/ 134217732) {
				label3_changes.$$scope = { dirty, ctx };
			}

			label3.$set(label3_changes);
			const label4_changes = {};
			if (dirty & /*$_*/ 16) label4_changes.label = /*$_*/ ctx[4]("gymRegister.gymPricing.currency");

			if (dirty & /*$$scope, actPrice*/ 134217732) {
				label4_changes.$$scope = { dirty, ctx };
			}

			label4.$set(label4_changes);
			const label5_changes = {};
			if (dirty & /*$_*/ 16) label5_changes.label = /*$_*/ ctx[4]("gymRegister.gymPricing.validForDays");

			if (dirty & /*$$scope, actPrice*/ 134217732) {
				label5_changes.$$scope = { dirty, ctx };
			}

			label5.$set(label5_changes);
			if ((!current || dirty & /*$_*/ 16) && t10_value !== (t10_value = /*$_*/ ctx[4]("gymRegister.gymPricing.addToList") + "")) set_data_dev(t10, t10_value);

			if (dirty & /*tableHeaders*/ 8) {
				each_value_2 = /*tableHeaders*/ ctx[3];
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_2$1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(tr, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_2.length;
			}

			if (dirty & /*deleteFromPricing, pricingGeneralData, tableHeaders, fillTableData*/ 393) {
				each_value = /*pricingGeneralData*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(table, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label0.$$.fragment, local);
			transition_in(label1.$$.fragment, local);
			transition_in(label2.$$.fragment, local);
			transition_in(label3.$$.fragment, local);
			transition_in(label4.$$.fragment, local);
			transition_in(label5.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label0.$$.fragment, local);
			transition_out(label1.$$.fragment, local);
			transition_out(label2.$$.fragment, local);
			transition_out(label3.$$.fragment, local);
			transition_out(label4.$$.fragment, local);
			transition_out(label5.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(label1, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(hr0);
			if (detaching) detach_dev(t2);
			destroy_component(label2, detaching);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(hr1);
			if (detaching) detach_dev(t4);
			destroy_component(label3, detaching);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(hr2);
			if (detaching) detach_dev(t6);
			destroy_component(label4, detaching);
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(hr3);
			if (detaching) detach_dev(t8);
			destroy_component(label5, detaching);
			if (detaching) detach_dev(t9);
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t11);
			if (detaching) detach_dev(hr4);
			if (detaching) detach_dev(t12);
			if (detaching) detach_dev(table);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let $_;
	validate_store(te, "_");
	component_subscribe($$self, te, $$value => $$invalidate(4, $_ = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Pricing", slots, []);
	let { selectedFacilities } = $$props;
	let { pricingGeneralData } = $$props;
	let actPrice = {};

	function addToPricing() {
		$$invalidate(0, pricingGeneralData = [...pricingGeneralData, actPrice]);
		$$invalidate(2, actPrice = { ...actPrice });
	}

	function fillTableData(price, header) {
		if (header.value === "categoryType") {
			return $_(`gymRegister.gymPricing.${price[header.value]}`);
		} else if (header.value === "selectedFacility") {
			if (price[header.value] === "generalPricing") {
				return $_(`gymRegister.gymPricing.${price[header.value]}`);
			}
		}

		return price[header.value];
	}

	function deleteFromPricing(el) {
		console.log(el);
		let indexOfEl = pricingGeneralData.indexOf(el);
		pricingGeneralData.splice(indexOfEl, 1);
		$$invalidate(0, pricingGeneralData);
	}

	const writable_props = ["selectedFacilities", "pricingGeneralData"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Pricing> was created with unknown prop '${key}'`);
	});

	function select_change_handler() {
		actPrice.selectedFacility = select_value(this);
		$$invalidate(2, actPrice);
		$$invalidate(1, selectedFacilities);
	}

	function dropdown_selected_binding(value) {
		actPrice.categoryType = value;
		$$invalidate(2, actPrice);
	}

	function input_value_binding(value) {
		actPrice.ticketType = value;
		$$invalidate(2, actPrice);
	}

	function input_value_binding_1(value) {
		actPrice.amount = value;
		$$invalidate(2, actPrice);
	}

	function input_value_binding_2(value) {
		actPrice.currency = value;
		$$invalidate(2, actPrice);
	}

	function input_value_binding_3(value) {
		actPrice.validForDays = value;
		$$invalidate(2, actPrice);
	}

	$$self.$$set = $$props => {
		if ("selectedFacilities" in $$props) $$invalidate(1, selectedFacilities = $$props.selectedFacilities);
		if ("pricingGeneralData" in $$props) $$invalidate(0, pricingGeneralData = $$props.pricingGeneralData);
	};

	$$self.$capture_state = () => ({
		_: te,
		Label,
		Input,
		Dropdown: DropdownSingle,
		selectedFacilities,
		pricingGeneralData,
		actPrice,
		addToPricing,
		fillTableData,
		deleteFromPricing,
		tableHeaders,
		$_,
		categories
	});

	$$self.$inject_state = $$props => {
		if ("selectedFacilities" in $$props) $$invalidate(1, selectedFacilities = $$props.selectedFacilities);
		if ("pricingGeneralData" in $$props) $$invalidate(0, pricingGeneralData = $$props.pricingGeneralData);
		if ("actPrice" in $$props) $$invalidate(2, actPrice = $$props.actPrice);
		if ("tableHeaders" in $$props) $$invalidate(3, tableHeaders = $$props.tableHeaders);
		if ("categories" in $$props) $$invalidate(5, categories = $$props.categories);
	};

	let tableHeaders;
	let categories;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$_*/ 16) {
			 $$invalidate(3, tableHeaders = [
				{
					value: "selectedFacility",
					label: $_("gymRegister.gymPricing.selectedFacility")
				},
				{
					value: "categoryType",
					label: $_("gymRegister.gymPricing.categoryType")
				},
				{
					value: "ticketType",
					label: $_("gymRegister.gymPricing.ticketType")
				},
				{
					value: "amount",
					label: $_("gymRegister.gymPricing.amount")
				},
				{
					value: "currency",
					label: $_("gymRegister.gymPricing.currency")
				},
				{
					value: "validForDays",
					label: $_("gymRegister.gymPricing.validForDays")
				}
			]);
		}

		if ($$self.$$.dirty & /*selectedFacilities*/ 2) {
			 console.log(selectedFacilities);
		}

		if ($$self.$$.dirty & /*$_*/ 16) {
			 $$invalidate(5, categories = [
				{
					value: "daily",
					label: $_("gymRegister.gymPricing.daily")
				},
				{
					value: "monthly",
					label: $_("gymRegister.gymPricing.monthly")
				},
				{
					value: "occasional",
					label: $_("gymRegister.gymPricing.occasional")
				}
			]);
		}
	};

	return [
		pricingGeneralData,
		selectedFacilities,
		actPrice,
		tableHeaders,
		$_,
		categories,
		addToPricing,
		fillTableData,
		deleteFromPricing,
		select_change_handler,
		dropdown_selected_binding,
		input_value_binding,
		input_value_binding_1,
		input_value_binding_2,
		input_value_binding_3
	];
}

class Pricing extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			selectedFacilities: 1,
			pricingGeneralData: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Pricing",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*selectedFacilities*/ ctx[1] === undefined && !("selectedFacilities" in props)) {
			console_1$1.warn("<Pricing> was created without expected prop 'selectedFacilities'");
		}

		if (/*pricingGeneralData*/ ctx[0] === undefined && !("pricingGeneralData" in props)) {
			console_1$1.warn("<Pricing> was created without expected prop 'pricingGeneralData'");
		}
	}

	get selectedFacilities() {
		throw new Error("<Pricing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedFacilities(value) {
		throw new Error("<Pricing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pricingGeneralData() {
		throw new Error("<Pricing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pricingGeneralData(value) {
		throw new Error("<Pricing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const gymInfos ={
    "gym":[
        {   
            "value":"name",
            "inputType":"Input",
            "maxLength":75,
            "required":true,
            "label":"Name",
            "type":"C",
            
        },
        {
            "value":"country",
            "inputType":"Input",
            "maxLength":75,
            "required":true,
            "label":"Country",
            "type":"C"
        },
        {
            "value":"postcode",
            "inputType":"Input",
            "maxLength":15,
            "required":true,
            "label":"Postcode",
            "type":"C"
        },
        {
            "value":"city",
            "inputType":"Input",
            "maxLength":100,
            "required":true,
            "label":"City",
            "type":"C"
        },
        {
            "value":"street",
            "inputType":"Input",
            "maxLength":75,
            "required":true,
            "label":"Street",
            "type":"C"
        },
        {
            "value":"streetNum",
            "inputType":"Input",
            "maxLength":10,
            "required":true,
            "label":"Street Number",
            "type":"C"
        },
        {
            "value":"floor",
            "inputType":"Input",
            "maxLength":10,
            "required":false,
            "label":"Floor",
            "type":"C"
        },
        {
            "value":"phoneNumber",
            "inputType":"Input",
            "maxLength":25,
            "required":true,
            "label":"Phone",
            "type":"P"
        },
        
        {
            "value":"description",
            "inputType":"Input",
            "maxLength":3500,
            "required":true,
            "label":"Description",
            "type":"C"
        },
        {
            "value":"shortDescription",
            "inputType":"Input",
            "maxLength":150,
            "required":true,
            "label":"Short Description",
            "type":"C"
        },
        {
            "value":"facebookUserId",
            "inputType":"Input",
            "maxLength":75,
            "required":false,
            "label":"Facebook",
            "type":"C"
        },
        {
            "value":"instagramUserId",
            "inputType":"Input",
            "maxLength":75,
            "required":false,
            "label":"Instagram",
            "type":"C"
        },
        {
            "value":"youtubeUserId",
            "inputType":"Input",
            "maxLength":75,
            "required":false,
            "label":"Youtube",
            "type":"C"
        },
        {
            "value":"twitterUserId",
            "inputType":"Input",
            "maxLength":75,
            "required":false,
            "label":"Twitter",
            "type":"C"
        },
        {
            "value":"webPageUserId",
            "inputType":"Input",
            "maxLength":75,
            "required":false,
            "label":"Website",
            "type":"C"
        }
        
        
    ]    
};

const openingInfos={
    "openingHoursForm":[
        {
            "value":"facilityName",
            "inputType":"Input",
            "type":"C",
            "maxLength" : 50,
            "required":false,
            "name":"Open times"
        },
        {
            "value":"mondayFrom",
            "inputType":"Number",
            "type":"T",
            "maxLength" : 5,
            "required":true,
            "name":"Monday from"
        },
        {
            "value":"mondayTo",
            "inputType":"Number",
            "type":"T",
            "maxLength" : 5,
            "required":true,
            "name":"Monday to",
        },
        {
            "value":"tuesdayFrom",
            "inputType":"Number",
            "type":"T",
            "maxLength" : 5,
            "required":true,
            "name":"Tuesday from",
        },
        {
            "value":"tuesdayTo",
            "inputType":"Number",
            "type":"T",
            "maxLength" : 5,
            "required":true,
            "name":"Tuesday to",
        },
        {
            "value":"wednesdayFrom",
            "inputType":"Number",
            "type":"T",
            "maxLength" : 5,
            "required":true,
            "name":"Wednesday from",
        },
        {
            "value":"wednesdayTo",
            "inputType":"Number",
            "type":"T",
            "maxLength" : 5,
            "required":true,
            "name":"Wednesday to",
        },
        {
            "value":"thursdayFrom",
            "inputType":"Number",
            "type":"T",
            "maxLength" : 5,
            "required":true,
            "name":"Thursday from",
        },
        {
            "value":"thursdayTo",
            "inputType":"Number",
            "type":"T",
            "maxLength" : 5,
            "required":true,
            "name":"Thursday to",
        },
        {
            "value":"fridayFrom",
            "inputType":"Number",
            "type":"T",
            "maxLength" : 5,
            "required":true,
            "name":"Friday from",
        },
        {
            "value":"fridayTo",
            "inputType":"Number",
            "type":"T",
            "maxLength" : 5,
            "required":true,
            "name":"Friday to",
        },
        {
            "value":"saturdayFrom",
            "inputType":"Number",
            "type":"T",
            "maxLength" : 5,
            "required":true,
            "name":"Saturday from",
        },
        {
            "value":"saturdayTo",
            "inputType":"Number",
            "type":"T",
            "maxLength" : 5,
            "required":true,
            "name":"Saturday to",
        },
        {
            "value":"sundayFrom",
            "inputType":"Number",
            "type":"T",
            "maxLength" : 5,
            "required":true,
            "name":"Sunday from",
        },
        {
            "value":"sundayTo",
            "inputType":"Number",
            "type":"T",
            "maxLength" : 5,
            "required":true,
            "name":"Sunday to",
        },
        
        
    ]    
};

/* src\components\GymForm\GymForm.svelte generated by Svelte v3.29.7 */

const { console: console_1$2 } = globals;
const file$4 = "src\\components\\GymForm\\GymForm.svelte";

// (44:8) <Step              title={$_('gymRegister.gymWizard.gymBasic')}              desc={$_('gymRegister.gymWizard.gymBasicDesc')}              icon={'icon'}              active>
function create_default_slot_4$1(ctx) {
	let gymgeneral;
	let updating_gymGeneralData;
	let current;

	function gymgeneral_gymGeneralData_binding(value) {
		/*gymgeneral_gymGeneralData_binding*/ ctx[4].call(null, value);
	}

	let gymgeneral_props = { gymGeneralCols: gymInfos.gym };

	if (/*form*/ ctx[0].gym !== void 0) {
		gymgeneral_props.gymGeneralData = /*form*/ ctx[0].gym;
	}

	gymgeneral = new General({ props: gymgeneral_props, $$inline: true });
	binding_callbacks.push(() => bind(gymgeneral, "gymGeneralData", gymgeneral_gymGeneralData_binding));

	const block = {
		c: function create() {
			create_component(gymgeneral.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(gymgeneral, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const gymgeneral_changes = {};

			if (!updating_gymGeneralData && dirty & /*form*/ 1) {
				updating_gymGeneralData = true;
				gymgeneral_changes.gymGeneralData = /*form*/ ctx[0].gym;
				add_flush_callback(() => updating_gymGeneralData = false);
			}

			gymgeneral.$set(gymgeneral_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(gymgeneral.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(gymgeneral.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(gymgeneral, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$1.name,
		type: "slot",
		source: "(44:8) <Step              title={$_('gymRegister.gymWizard.gymBasic')}              desc={$_('gymRegister.gymWizard.gymBasicDesc')}              icon={'icon'}              active>",
		ctx
	});

	return block;
}

// (1:0) <script>      import { _ }
function create_catch_block(ctx) {
	const block = {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_catch_block.name,
		type: "catch",
		source: "(1:0) <script>      import { _ }",
		ctx
	});

	return block;
}

// (57:53)               <Facilities                  bind:facilityGeneralData={form.facilities}
function create_then_block(ctx) {
	let facilities;
	let updating_facilityGeneralData;
	let current;

	function facilities_facilityGeneralData_binding(value) {
		/*facilities_facilityGeneralData_binding*/ ctx[5].call(null, value);
	}

	let facilities_props = {
		gymFacilityCols: /*facilityCodes*/ ctx[3]
	};

	if (/*form*/ ctx[0].facilities !== void 0) {
		facilities_props.facilityGeneralData = /*form*/ ctx[0].facilities;
	}

	facilities = new Facilities({ props: facilities_props, $$inline: true });
	binding_callbacks.push(() => bind(facilities, "facilityGeneralData", facilities_facilityGeneralData_binding));

	const block = {
		c: function create() {
			create_component(facilities.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(facilities, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const facilities_changes = {};

			if (!updating_facilityGeneralData && dirty & /*form*/ 1) {
				updating_facilityGeneralData = true;
				facilities_changes.facilityGeneralData = /*form*/ ctx[0].facilities;
				add_flush_callback(() => updating_facilityGeneralData = false);
			}

			facilities.$set(facilities_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(facilities.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(facilities.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(facilities, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_then_block.name,
		type: "then",
		source: "(57:53)               <Facilities                  bind:facilityGeneralData={form.facilities}",
		ctx
	});

	return block;
}

// (1:0) <script>      import { _ }
function create_pending_block(ctx) {
	const block = {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_pending_block.name,
		type: "pending",
		source: "(1:0) <script>      import { _ }",
		ctx
	});

	return block;
}

// (53:8) <Step              title={$_('gymRegister.gymWizard.gymFacility')}              desc={$_('gymRegister.gymWizard.gymFacilityDesc')}              icon={'icon'}>
function create_default_slot_3$2(ctx) {
	let await_block_anchor;
	let promise;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 3,
		blocks: [,,,]
	};

	handle_promise(promise = /*facilityCodes*/ ctx[3], info);

	const block = {
		c: function create() {
			await_block_anchor = empty();
			info.block.c();
		},
		m: function mount(target, anchor) {
			insert_dev(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			{
				const child_ctx = ctx.slice();
				child_ctx[3] = info.resolved;
				info.block.p(child_ctx, dirty);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$2.name,
		type: "slot",
		source: "(53:8) <Step              title={$_('gymRegister.gymWizard.gymFacility')}              desc={$_('gymRegister.gymWizard.gymFacilityDesc')}              icon={'icon'}>",
		ctx
	});

	return block;
}

// (63:8) <Step              title={$_('gymRegister.gymWizard.gymOpening')}              desc={$_('gymRegister.gymWizard.gymOpeningDesc')}              icon={'icon'}>
function create_default_slot_2$2(ctx) {
	let opening;
	let updating_openingGeneralData;
	let updating_facilities;
	let current;

	function opening_openingGeneralData_binding(value) {
		/*opening_openingGeneralData_binding*/ ctx[6].call(null, value);
	}

	function opening_facilities_binding(value) {
		/*opening_facilities_binding*/ ctx[7].call(null, value);
	}

	let opening_props = { openingInfos };

	if (/*form*/ ctx[0].openings !== void 0) {
		opening_props.openingGeneralData = /*form*/ ctx[0].openings;
	}

	if (/*form*/ ctx[0].facilities !== void 0) {
		opening_props.facilities = /*form*/ ctx[0].facilities;
	}

	opening = new Opening({ props: opening_props, $$inline: true });
	binding_callbacks.push(() => bind(opening, "openingGeneralData", opening_openingGeneralData_binding));
	binding_callbacks.push(() => bind(opening, "facilities", opening_facilities_binding));

	const block = {
		c: function create() {
			create_component(opening.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(opening, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const opening_changes = {};

			if (!updating_openingGeneralData && dirty & /*form*/ 1) {
				updating_openingGeneralData = true;
				opening_changes.openingGeneralData = /*form*/ ctx[0].openings;
				add_flush_callback(() => updating_openingGeneralData = false);
			}

			if (!updating_facilities && dirty & /*form*/ 1) {
				updating_facilities = true;
				opening_changes.facilities = /*form*/ ctx[0].facilities;
				add_flush_callback(() => updating_facilities = false);
			}

			opening.$set(opening_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(opening.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(opening.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(opening, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$2.name,
		type: "slot",
		source: "(63:8) <Step              title={$_('gymRegister.gymWizard.gymOpening')}              desc={$_('gymRegister.gymWizard.gymOpeningDesc')}              icon={'icon'}>",
		ctx
	});

	return block;
}

// (73:8) <Step title={$_('gymRegister.gymWizard.gymPricing')} desc={$_('gymRegister.gymWizard.gymPricingDesc')} icon={'icon'} >
function create_default_slot_1$2(ctx) {
	let pricing;
	let updating_pricingGeneralData;
	let current;

	function pricing_pricingGeneralData_binding(value) {
		/*pricing_pricingGeneralData_binding*/ ctx[8].call(null, value);
	}

	let pricing_props = {
		selectedFacilities: /*form*/ ctx[0].facilities
	};

	if (/*form*/ ctx[0].pricing !== void 0) {
		pricing_props.pricingGeneralData = /*form*/ ctx[0].pricing;
	}

	pricing = new Pricing({ props: pricing_props, $$inline: true });
	binding_callbacks.push(() => bind(pricing, "pricingGeneralData", pricing_pricingGeneralData_binding));

	const block = {
		c: function create() {
			create_component(pricing.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(pricing, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const pricing_changes = {};
			if (dirty & /*form*/ 1) pricing_changes.selectedFacilities = /*form*/ ctx[0].facilities;

			if (!updating_pricingGeneralData && dirty & /*form*/ 1) {
				updating_pricingGeneralData = true;
				pricing_changes.pricingGeneralData = /*form*/ ctx[0].pricing;
				add_flush_callback(() => updating_pricingGeneralData = false);
			}

			pricing.$set(pricing_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(pricing.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(pricing.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(pricing, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(73:8) <Step title={$_('gymRegister.gymWizard.gymPricing')} desc={$_('gymRegister.gymWizard.gymPricingDesc')} icon={'icon'} >",
		ctx
	});

	return block;
}

// (43:4) <Wizard on:wizardDone={sendData} title={$_('gymRegister.title')}>
function create_default_slot$4(ctx) {
	let step0;
	let t0;
	let step1;
	let t1;
	let step2;
	let t2;
	let step3;
	let current;

	step0 = new Step({
			props: {
				title: /*$_*/ ctx[1]("gymRegister.gymWizard.gymBasic"),
				desc: /*$_*/ ctx[1]("gymRegister.gymWizard.gymBasicDesc"),
				icon: "icon",
				active: true,
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	step1 = new Step({
			props: {
				title: /*$_*/ ctx[1]("gymRegister.gymWizard.gymFacility"),
				desc: /*$_*/ ctx[1]("gymRegister.gymWizard.gymFacilityDesc"),
				icon: "icon",
				$$slots: { default: [create_default_slot_3$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	step2 = new Step({
			props: {
				title: /*$_*/ ctx[1]("gymRegister.gymWizard.gymOpening"),
				desc: /*$_*/ ctx[1]("gymRegister.gymWizard.gymOpeningDesc"),
				icon: "icon",
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	step3 = new Step({
			props: {
				title: /*$_*/ ctx[1]("gymRegister.gymWizard.gymPricing"),
				desc: /*$_*/ ctx[1]("gymRegister.gymWizard.gymPricingDesc"),
				icon: "icon",
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(step0.$$.fragment);
			t0 = space();
			create_component(step1.$$.fragment);
			t1 = space();
			create_component(step2.$$.fragment);
			t2 = space();
			create_component(step3.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(step0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(step1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(step2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(step3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const step0_changes = {};
			if (dirty & /*$_*/ 2) step0_changes.title = /*$_*/ ctx[1]("gymRegister.gymWizard.gymBasic");
			if (dirty & /*$_*/ 2) step0_changes.desc = /*$_*/ ctx[1]("gymRegister.gymWizard.gymBasicDesc");

			if (dirty & /*$$scope, form*/ 513) {
				step0_changes.$$scope = { dirty, ctx };
			}

			step0.$set(step0_changes);
			const step1_changes = {};
			if (dirty & /*$_*/ 2) step1_changes.title = /*$_*/ ctx[1]("gymRegister.gymWizard.gymFacility");
			if (dirty & /*$_*/ 2) step1_changes.desc = /*$_*/ ctx[1]("gymRegister.gymWizard.gymFacilityDesc");

			if (dirty & /*$$scope, form*/ 513) {
				step1_changes.$$scope = { dirty, ctx };
			}

			step1.$set(step1_changes);
			const step2_changes = {};
			if (dirty & /*$_*/ 2) step2_changes.title = /*$_*/ ctx[1]("gymRegister.gymWizard.gymOpening");
			if (dirty & /*$_*/ 2) step2_changes.desc = /*$_*/ ctx[1]("gymRegister.gymWizard.gymOpeningDesc");

			if (dirty & /*$$scope, form*/ 513) {
				step2_changes.$$scope = { dirty, ctx };
			}

			step2.$set(step2_changes);
			const step3_changes = {};
			if (dirty & /*$_*/ 2) step3_changes.title = /*$_*/ ctx[1]("gymRegister.gymWizard.gymPricing");
			if (dirty & /*$_*/ 2) step3_changes.desc = /*$_*/ ctx[1]("gymRegister.gymWizard.gymPricingDesc");

			if (dirty & /*$$scope, form*/ 513) {
				step3_changes.$$scope = { dirty, ctx };
			}

			step3.$set(step3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(step0.$$.fragment, local);
			transition_in(step1.$$.fragment, local);
			transition_in(step2.$$.fragment, local);
			transition_in(step3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(step0.$$.fragment, local);
			transition_out(step1.$$.fragment, local);
			transition_out(step2.$$.fragment, local);
			transition_out(step3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(step0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(step1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(step2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(step3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(43:4) <Wizard on:wizardDone={sendData} title={$_('gymRegister.title')}>",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let div;
	let wizard;
	let current;

	wizard = new Wizard({
			props: {
				title: /*$_*/ ctx[1]("gymRegister.title"),
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	wizard.$on("wizardDone", /*sendData*/ ctx[2]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(wizard.$$.fragment);
			attr_dev(div, "class", "gymFormContainer svelte-10as5ws");
			add_location(div, file$4, 41, 0, 1162);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(wizard, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const wizard_changes = {};
			if (dirty & /*$_*/ 2) wizard_changes.title = /*$_*/ ctx[1]("gymRegister.title");

			if (dirty & /*$$scope, $_, form*/ 515) {
				wizard_changes.$$scope = { dirty, ctx };
			}

			wizard.$set(wizard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(wizard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(wizard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(wizard);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let $_;
	validate_store(te, "_");
	component_subscribe($$self, te, $$value => $$invalidate(1, $_ = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GymForm", slots, []);
	let facilityCodes = gymCodes.getFacilityCodes();

	let form = {
		gym: {},
		facilities: [],
		openings: [],
		pricing: []
	};

	function sendData() {
		gymRegisterStore.submitForm(form);
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<GymForm> was created with unknown prop '${key}'`);
	});

	function gymgeneral_gymGeneralData_binding(value) {
		form.gym = value;
		$$invalidate(0, form);
	}

	function facilities_facilityGeneralData_binding(value) {
		form.facilities = value;
		$$invalidate(0, form);
	}

	function opening_openingGeneralData_binding(value) {
		form.openings = value;
		$$invalidate(0, form);
	}

	function opening_facilities_binding(value) {
		form.facilities = value;
		$$invalidate(0, form);
	}

	function pricing_pricingGeneralData_binding(value) {
		form.pricing = value;
		$$invalidate(0, form);
	}

	$$self.$capture_state = () => ({
		_: te,
		Wizard,
		Step,
		gymRegisterStore,
		Facilities,
		GymGeneral: General,
		Opening,
		Pricing,
		gymInfos,
		openingInfos,
		gymCodes,
		facilityCodes,
		form,
		sendData,
		$_
	});

	$$self.$inject_state = $$props => {
		if ("facilityCodes" in $$props) $$invalidate(3, facilityCodes = $$props.facilityCodes);
		if ("form" in $$props) $$invalidate(0, form = $$props.form);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*form*/ 1) {
			 console.log(form);
		}
	};

	return [
		form,
		$_,
		sendData,
		facilityCodes,
		gymgeneral_gymGeneralData_binding,
		facilities_facilityGeneralData_binding,
		opening_openingGeneralData_binding,
		opening_facilities_binding,
		pricing_pricingGeneralData_binding
	];
}

class GymForm extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GymForm",
			options,
			id: create_fragment$5.name
		});
	}
}

/* src\pages\register\gym.svelte generated by Svelte v3.29.7 */

function create_fragment$6(ctx) {
	let gymregister;
	let current;
	gymregister = new GymForm({ $$inline: true });

	const block = {
		c: function create() {
			create_component(gymregister.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(gymregister, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(gymregister.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(gymregister.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(gymregister, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Gym", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Gym> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ GymRegister: GymForm });
	return [];
}

class Gym extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Gym",
			options,
			id: create_fragment$6.name
		});
	}
}

export default Gym;
//# sourceMappingURL=gym-3198e276.js.map
