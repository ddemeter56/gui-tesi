
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, c as create_slot, v as validate_slots, q as setContext, r as onDestroy, w as writable, j as element, x as attr_dev, k as add_location, e as insert_dev, u as update_slot, t as transition_in, f as transition_out, h as detach_dev, y as getContext, z as null_to_empty, o as append_dev, A as validate_store, B as component_subscribe, C as empty, D as group_outros, E as check_outros, F as toggle_class, G as listen_dev, H as createEventDispatcher, I as binding_callbacks, J as bind, K as handle_promise, a as create_component, b as space, L as set_style, m as mount_component, g as destroy_component, M as select_multiple_value, O as add_flush_callback, P as validate_each_argument, l as text, n as noop, Q as add_render_callback, R as select_options, T as destroy_each, p as set_data_dev, U as url, V as DropdownSingle, W as globals } from './main-ec673aad.js';
import { NotificationDisplay } from '@beyonk/svelte-notifications';
import { g as getData, L as Label, I as Input } from './backendComm-58342082.js';
import { g as gymCodes } from './gymCodes-92324335.js';

/* src\components\Tab\Tabs.svelte generated by Svelte v3.29.7 */
const file = "src\\components\\Tab\\Tabs.svelte";

function create_fragment(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", div_class_value = "" + (/*tabListPosition*/ ctx[0] + " tabs" + " svelte-qtqxcd"));
			add_location(div, file, 86, 0, 1835);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}

			if (!current || dirty & /*tabListPosition*/ 1 && div_class_value !== (div_class_value = "" + (/*tabListPosition*/ ctx[0] + " tabs" + " svelte-qtqxcd"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const TABS = {};

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Tabs", slots, ['default']);
	let { tabListPosition = "top" } = $$props;
	const tabs = [];
	const panels = [];
	const selectedTab = writable(null);
	const selectedPanel = writable(null);

	setContext(TABS, {
		registerTab: tab => {
			tabs.push(tab);
			selectedTab.update(current => current || tab);

			onDestroy(() => {
				const i = tabs.indexOf(tab);
				tabs.splice(i, 1);

				selectedTab.update(current => current === tab
				? tabs[i] || tabs[tabs.length - 1]
				: current);
			});
		},
		registerPanel: panel => {
			panels.push(panel);
			selectedPanel.update(current => current || panel);

			onDestroy(() => {
				const i = panels.indexOf(panel);
				panels.splice(i, 1);

				selectedPanel.update(current => current === panel
				? panels[i] || panels[panels.length - 1]
				: current);
			});
		},
		selectTab: tab => {
			const i = tabs.indexOf(tab);
			selectedTab.set(tab);
			selectedPanel.set(panels[i]);
		},
		selectedTab,
		selectedPanel,
		tabListPosition
	});

	const writable_props = ["tabListPosition"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tabs> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("tabListPosition" in $$props) $$invalidate(0, tabListPosition = $$props.tabListPosition);
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		TABS,
		setContext,
		onDestroy,
		writable,
		tabListPosition,
		tabs,
		panels,
		selectedTab,
		selectedPanel
	});

	$$self.$inject_state = $$props => {
		if ("tabListPosition" in $$props) $$invalidate(0, tabListPosition = $$props.tabListPosition);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [tabListPosition, $$scope, slots];
}

class Tabs extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { tabListPosition: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tabs",
			options,
			id: create_fragment.name
		});
	}

	get tabListPosition() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabListPosition(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\Tab\TabList.svelte generated by Svelte v3.29.7 */
const file$1 = "src\\components\\Tab\\TabList.svelte";

function create_fragment$1(ctx) {
	let div1;
	let div0;
	let div0_class_value;
	let div0_style_value;
	let div1_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div0, "class", div0_class_value = "" + (/*tabListPosition*/ ctx[2] + " " + `adjust_${/*adjust*/ ctx[1]}` + " scrollable tab-list" + " svelte-1dlggd"));
			attr_dev(div0, "style", div0_style_value = /*getStyle*/ ctx[3](/*tabListPosition*/ ctx[2], /*thickness*/ ctx[0]));
			add_location(div0, file$1, 115, 0, 2237);
			attr_dev(div1, "class", div1_class_value = "" + (null_to_empty(/*getContainerClass*/ ctx[4]()) + " svelte-1dlggd"));
			add_location(div1, file$1, 114, 0, 2201);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			if (!current || dirty & /*adjust*/ 2 && div0_class_value !== (div0_class_value = "" + (/*tabListPosition*/ ctx[2] + " " + `adjust_${/*adjust*/ ctx[1]}` + " scrollable tab-list" + " svelte-1dlggd"))) {
				attr_dev(div0, "class", div0_class_value);
			}

			if (!current || dirty & /*thickness*/ 1 && div0_style_value !== (div0_style_value = /*getStyle*/ ctx[3](/*tabListPosition*/ ctx[2], /*thickness*/ ctx[0]))) {
				attr_dev(div0, "style", div0_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TabList", slots, ['default']);
	let { thickness = null } = $$props;
	let { adjust = "left" } = $$props;
	let { style = "" } = $$props;
	const { tabListPosition } = getContext(TABS);

	function getStyle(pos, thick) {
		if (!thick) {
			return style;
		}

		if (pos === "top" || pos === "bottom") {
			return `height: ${thick}px; min-height: ${thick}px; max-height: ${thick}px;${style}`;
		}

		if (pos === "left" || pos === "right") {
			return `width: ${thick}px; min-width: ${thick}px; max-width: ${thick}px;${style}`;
		}

		return style;
	}

	function getContainerClass() {
		let c;

		switch (tabListPosition) {
			case "top":
				c = "tablistContainerH borderBottom";
				break;
			case "bottom":
				c = "tablistContainerH  borderTop";
				break;
			case "left":
				c = "tablistContainerV  borderRight";
				break;
			default:
				c = "tablistContainerV  borderLeft";
		}

		return c;
	}

	const writable_props = ["thickness", "adjust", "style"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TabList> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("thickness" in $$props) $$invalidate(0, thickness = $$props.thickness);
		if ("adjust" in $$props) $$invalidate(1, adjust = $$props.adjust);
		if ("style" in $$props) $$invalidate(5, style = $$props.style);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		TABS,
		thickness,
		adjust,
		style,
		tabListPosition,
		getStyle,
		getContainerClass
	});

	$$self.$inject_state = $$props => {
		if ("thickness" in $$props) $$invalidate(0, thickness = $$props.thickness);
		if ("adjust" in $$props) $$invalidate(1, adjust = $$props.adjust);
		if ("style" in $$props) $$invalidate(5, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		thickness,
		adjust,
		tabListPosition,
		getStyle,
		getContainerClass,
		style,
		$$scope,
		slots
	];
}

class TabList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { thickness: 0, adjust: 1, style: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TabList",
			options,
			id: create_fragment$1.name
		});
	}

	get thickness() {
		throw new Error("<TabList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set thickness(value) {
		throw new Error("<TabList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get adjust() {
		throw new Error("<TabList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set adjust(value) {
		throw new Error("<TabList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<TabList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<TabList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\Tab\TabPanel.svelte generated by Svelte v3.29.7 */
const file$2 = "src\\components\\Tab\\TabPanel.svelte";

// (21:0) {#if $selectedPanel === panel}
function create_if_block(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", div_class_value = "tab-panel scrollable " + /*cssClass*/ ctx[1] + " svelte-1kuj9kb");
			attr_dev(div, "style", /*style*/ ctx[0]);
			add_location(div, file$2, 21, 2, 358);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			if (!current || dirty & /*cssClass*/ 2 && div_class_value !== (div_class_value = "tab-panel scrollable " + /*cssClass*/ ctx[1] + " svelte-1kuj9kb")) {
				attr_dev(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 1) {
				attr_dev(div, "style", /*style*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(21:0) {#if $selectedPanel === panel}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*$selectedPanel*/ ctx[2] === /*panel*/ ctx[3] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$selectedPanel*/ ctx[2] === /*panel*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$selectedPanel*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let $selectedPanel;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TabPanel", slots, ['default']);
	let { style = "" } = $$props;
	let { cssClass = "" } = $$props;
	const panel = {};
	const { registerPanel, selectedPanel } = getContext(TABS);
	validate_store(selectedPanel, "selectedPanel");
	component_subscribe($$self, selectedPanel, value => $$invalidate(2, $selectedPanel = value));
	registerPanel(panel);
	const writable_props = ["style", "cssClass"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TabPanel> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("style" in $$props) $$invalidate(0, style = $$props.style);
		if ("cssClass" in $$props) $$invalidate(1, cssClass = $$props.cssClass);
		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		TABS,
		style,
		cssClass,
		panel,
		registerPanel,
		selectedPanel,
		$selectedPanel
	});

	$$self.$inject_state = $$props => {
		if ("style" in $$props) $$invalidate(0, style = $$props.style);
		if ("cssClass" in $$props) $$invalidate(1, cssClass = $$props.cssClass);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [style, cssClass, $selectedPanel, panel, selectedPanel, $$scope, slots];
}

class TabPanel extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { style: 0, cssClass: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TabPanel",
			options,
			id: create_fragment$2.name
		});
	}

	get style() {
		throw new Error("<TabPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<TabPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get cssClass() {
		throw new Error("<TabPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set cssClass(value) {
		throw new Error("<TabPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\Tab\Tab.svelte generated by Svelte v3.29.7 */
const file$3 = "src\\components\\Tab\\Tab.svelte";

function create_fragment$3(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", "tab svelte-1eilkx2");
			toggle_class(div, "selectedTab", /*$selectedTab*/ ctx[0] === /*tab*/ ctx[1]);
			add_location(div, file$3, 32, 0, 530);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*click_handler*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			if (dirty & /*$selectedTab, tab*/ 3) {
				toggle_class(div, "selectedTab", /*$selectedTab*/ ctx[0] === /*tab*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let $selectedTab;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Tab", slots, ['default']);
	const tab = {};
	const { registerTab, selectTab, selectedTab } = getContext(TABS);
	validate_store(selectedTab, "selectedTab");
	component_subscribe($$self, selectedTab, value => $$invalidate(0, $selectedTab = value));
	registerTab(tab);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tab> was created with unknown prop '${key}'`);
	});

	const click_handler = () => selectTab(tab);

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		TABS,
		tab,
		registerTab,
		selectTab,
		selectedTab,
		$selectedTab
	});

	return [$selectedTab, tab, selectTab, selectedTab, $$scope, slots, click_handler];
}

class Tab extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tab",
			options,
			id: create_fragment$3.name
		});
	}
}

const pageSize = 50;

function createResultStore() {
	const { subscribe, set } = writable({ gyms: [] });

	return {
    subscribe,
		searchGyms: (params) => getData(`http://localhost/api/public/list/gym?${params}`).then((result) => {
			set(result);
		})
	};
}

const gymSearchResult = createResultStore();

let queryOptions = {
	page: 1,
	sortByProperty: 'averagePrice',
	sortByMethod: 'ASC'
};

let searchForm = {};


function createQuery(obj) {
	let str = '';
	searchForm = obj;
	obj = { ...obj, ...queryOptions, pageSize };
	for (let key in obj) {
		if(obj[key]) {
			if (str !== '') {
					str += '&';
			}

			str += key + '=' + encodeURIComponent(obj[key]);
		}
	}
	return str;
}

/* src\components\Search\GymSearch.svelte generated by Svelte v3.29.7 */
const file$4 = "src\\components\\Search\\GymSearch.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

// (38:2) <Label label='Ország'>
function create_default_slot_4(ctx) {
	let input;
	let updating_value;
	let current;

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[4].call(null, value);
	}

	let input_props = { type: "C", length: "40" };

	if (/*gymSearchParams*/ ctx[0].country !== void 0) {
		input_props.value = /*gymSearchParams*/ ctx[0].country;
	}

	input = new Input({ props: input_props, $$inline: true });
	binding_callbacks.push(() => bind(input, "value", input_value_binding));

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const input_changes = {};

			if (!updating_value && dirty & /*gymSearchParams*/ 1) {
				updating_value = true;
				input_changes.value = /*gymSearchParams*/ ctx[0].country;
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(38:2) <Label label='Ország'>",
		ctx
	});

	return block;
}

// (41:2) <Label label='Város'>
function create_default_slot_3(ctx) {
	let input;
	let updating_value;
	let current;

	function input_value_binding_1(value) {
		/*input_value_binding_1*/ ctx[5].call(null, value);
	}

	let input_props = { type: "C", length: "40" };

	if (/*gymSearchParams*/ ctx[0].city !== void 0) {
		input_props.value = /*gymSearchParams*/ ctx[0].city;
	}

	input = new Input({ props: input_props, $$inline: true });
	binding_callbacks.push(() => bind(input, "value", input_value_binding_1));

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const input_changes = {};

			if (!updating_value && dirty & /*gymSearchParams*/ 1) {
				updating_value = true;
				input_changes.value = /*gymSearchParams*/ ctx[0].city;
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(41:2) <Label label='Város'>",
		ctx
	});

	return block;
}

// (44:2) <Label label='Ár tól-ig'>
function create_default_slot_2(ctx) {
	let input0;
	let updating_value;
	let t;
	let input1;
	let updating_value_1;
	let current;

	function input0_value_binding(value) {
		/*input0_value_binding*/ ctx[6].call(null, value);
	}

	let input0_props = { type: "N" };

	if (/*gymSearchParams*/ ctx[0].minPrice !== void 0) {
		input0_props.value = /*gymSearchParams*/ ctx[0].minPrice;
	}

	input0 = new Input({ props: input0_props, $$inline: true });
	binding_callbacks.push(() => bind(input0, "value", input0_value_binding));

	function input1_value_binding(value) {
		/*input1_value_binding*/ ctx[7].call(null, value);
	}

	let input1_props = { type: "N" };

	if (/*gymSearchParams*/ ctx[0].maxPrice !== void 0) {
		input1_props.value = /*gymSearchParams*/ ctx[0].maxPrice;
	}

	input1 = new Input({ props: input1_props, $$inline: true });
	binding_callbacks.push(() => bind(input1, "value", input1_value_binding));

	const block = {
		c: function create() {
			create_component(input0.$$.fragment);
			t = space();
			create_component(input1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(input0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(input1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const input0_changes = {};

			if (!updating_value && dirty & /*gymSearchParams*/ 1) {
				updating_value = true;
				input0_changes.value = /*gymSearchParams*/ ctx[0].minPrice;
				add_flush_callback(() => updating_value = false);
			}

			input0.$set(input0_changes);
			const input1_changes = {};

			if (!updating_value_1 && dirty & /*gymSearchParams*/ 1) {
				updating_value_1 = true;
				input1_changes.value = /*gymSearchParams*/ ctx[0].maxPrice;
				add_flush_callback(() => updating_value_1 = false);
			}

			input1.$set(input1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input0.$$.fragment, local);
			transition_in(input1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input0.$$.fragment, local);
			transition_out(input1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(input1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(44:2) <Label label='Ár tól-ig'>",
		ctx
	});

	return block;
}

// (48:2) <Label label='Nyitvatartás'>
function create_default_slot_1(ctx) {
	let input0;
	let updating_value;
	let t;
	let input1;
	let updating_value_1;
	let current;

	function input0_value_binding_1(value) {
		/*input0_value_binding_1*/ ctx[8].call(null, value);
	}

	let input0_props = { type: "T" };

	if (/*gymSearchParams*/ ctx[0].openBefore !== void 0) {
		input0_props.value = /*gymSearchParams*/ ctx[0].openBefore;
	}

	input0 = new Input({ props: input0_props, $$inline: true });
	binding_callbacks.push(() => bind(input0, "value", input0_value_binding_1));

	function input1_value_binding_1(value) {
		/*input1_value_binding_1*/ ctx[9].call(null, value);
	}

	let input1_props = { type: "T" };

	if (/*gymSearchParams*/ ctx[0].openAfter !== void 0) {
		input1_props.value = /*gymSearchParams*/ ctx[0].openAfter;
	}

	input1 = new Input({ props: input1_props, $$inline: true });
	binding_callbacks.push(() => bind(input1, "value", input1_value_binding_1));

	const block = {
		c: function create() {
			create_component(input0.$$.fragment);
			t = space();
			create_component(input1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(input0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(input1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const input0_changes = {};

			if (!updating_value && dirty & /*gymSearchParams*/ 1) {
				updating_value = true;
				input0_changes.value = /*gymSearchParams*/ ctx[0].openBefore;
				add_flush_callback(() => updating_value = false);
			}

			input0.$set(input0_changes);
			const input1_changes = {};

			if (!updating_value_1 && dirty & /*gymSearchParams*/ 1) {
				updating_value_1 = true;
				input1_changes.value = /*gymSearchParams*/ ctx[0].openAfter;
				add_flush_callback(() => updating_value_1 = false);
			}

			input1.$set(input1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input0.$$.fragment, local);
			transition_in(input1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input0.$$.fragment, local);
			transition_out(input1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(input1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(48:2) <Label label='Nyitvatartás'>",
		ctx
	});

	return block;
}

// (1:0) <script>   import Label from '../Label/Label.svelte';   import Input from '../Input/Input.svelte';   import { gymCodes }
function create_catch_block(ctx) {
	const block = { c: noop, m: noop, p: noop, d: noop };

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_catch_block.name,
		type: "catch",
		source: "(1:0) <script>   import Label from '../Label/Label.svelte';   import Input from '../Input/Input.svelte';   import { gymCodes }",
		ctx
	});

	return block;
}

// (53:43)        <select class="allFacilityList" multiple bind:value={facilitiesCodes}
function create_then_block(ctx) {
	let select;
	let mounted;
	let dispose;
	let each_value = /*facilityList*/ ctx[3].facilities;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(select, "class", "allFacilityList");
			select.multiple = true;
			if (/*facilitiesCodes*/ ctx[1] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[10].call(select));
			add_location(select, file$4, 53, 6, 1621);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_options(select, /*facilitiesCodes*/ ctx[1]);

			if (!mounted) {
				dispose = listen_dev(select, "change", /*select_change_handler*/ ctx[10]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*facilityList*/ 8) {
				each_value = /*facilityList*/ ctx[3].facilities;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*facilitiesCodes, facilityList*/ 10) {
				select_options(select, /*facilitiesCodes*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_then_block.name,
		type: "then",
		source: "(53:43)        <select class=\\\"allFacilityList\\\" multiple bind:value={facilitiesCodes}",
		ctx
	});

	return block;
}

// (55:10) {#each facilityList.facilities as fac}
function create_each_block(ctx) {
	let option;
	let t_value = /*fac*/ ctx[12].name + "";
	let t;
	let option_value_value;

	const block = {
		c: function create() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*fac*/ ctx[12];
			option.value = option.__value;
			add_location(option, file$4, 55, 14, 1755);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(55:10) {#each facilityList.facilities as fac}",
		ctx
	});

	return block;
}

// (1:0) <script>   import Label from '../Label/Label.svelte';   import Input from '../Input/Input.svelte';   import { gymCodes }
function create_pending_block(ctx) {
	const block = { c: noop, m: noop, p: noop, d: noop };

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_pending_block.name,
		type: "pending",
		source: "(1:0) <script>   import Label from '../Label/Label.svelte';   import Input from '../Input/Input.svelte';   import { gymCodes }",
		ctx
	});

	return block;
}

// (52:2) <Label label='Létesítmények'>
function create_default_slot(ctx) {
	let await_block_anchor;
	let promise;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 3
	};

	handle_promise(promise = /*facilityList*/ ctx[3], info);

	const block = {
		c: function create() {
			await_block_anchor = empty();
			info.block.c();
		},
		m: function mount(target, anchor) {
			insert_dev(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			{
				const child_ctx = ctx.slice();
				child_ctx[3] = info.resolved;
				info.block.p(child_ctx, dirty);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(52:2) <Label label='Létesítmények'>",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let div;
	let label0;
	let t0;
	let label1;
	let t1;
	let label2;
	let t2;
	let label3;
	let t3;
	let label4;
	let t4;
	let button;
	let current;
	let mounted;
	let dispose;

	label0 = new Label({
			props: {
				label: "Ország",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label1 = new Label({
			props: {
				label: "Város",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label2 = new Label({
			props: {
				label: "Ár tól-ig",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label3 = new Label({
			props: {
				label: "Nyitvatartás",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label4 = new Label({
			props: {
				label: "Létesítmények",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(label0.$$.fragment);
			t0 = space();
			create_component(label1.$$.fragment);
			t1 = space();
			create_component(label2.$$.fragment);
			t2 = space();
			create_component(label3.$$.fragment);
			t3 = space();
			create_component(label4.$$.fragment);
			t4 = space();
			button = element("button");
			button.textContent = "Keresés";
			set_style(button, "float", "right");
			set_style(button, "margin-right", "15px");
			set_style(button, "margin-bottom", "15px");
			add_location(button, file$4, 60, 2, 1855);
			attr_dev(div, "class", "searchHolder scrollable svelte-gmgv5d");
			add_location(div, file$4, 36, 0, 968);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(label0, div, null);
			append_dev(div, t0);
			mount_component(label1, div, null);
			append_dev(div, t1);
			mount_component(label2, div, null);
			append_dev(div, t2);
			mount_component(label3, div, null);
			append_dev(div, t3);
			mount_component(label4, div, null);
			append_dev(div, t4);
			append_dev(div, button);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*searchedPressed*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const label0_changes = {};

			if (dirty & /*$$scope, gymSearchParams*/ 32769) {
				label0_changes.$$scope = { dirty, ctx };
			}

			label0.$set(label0_changes);
			const label1_changes = {};

			if (dirty & /*$$scope, gymSearchParams*/ 32769) {
				label1_changes.$$scope = { dirty, ctx };
			}

			label1.$set(label1_changes);
			const label2_changes = {};

			if (dirty & /*$$scope, gymSearchParams*/ 32769) {
				label2_changes.$$scope = { dirty, ctx };
			}

			label2.$set(label2_changes);
			const label3_changes = {};

			if (dirty & /*$$scope, gymSearchParams*/ 32769) {
				label3_changes.$$scope = { dirty, ctx };
			}

			label3.$set(label3_changes);
			const label4_changes = {};

			if (dirty & /*$$scope, facilitiesCodes*/ 32770) {
				label4_changes.$$scope = { dirty, ctx };
			}

			label4.$set(label4_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label0.$$.fragment, local);
			transition_in(label1.$$.fragment, local);
			transition_in(label2.$$.fragment, local);
			transition_in(label3.$$.fragment, local);
			transition_in(label4.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label0.$$.fragment, local);
			transition_out(label1.$$.fragment, local);
			transition_out(label2.$$.fragment, local);
			transition_out(label3.$$.fragment, local);
			transition_out(label4.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(label0);
			destroy_component(label1);
			destroy_component(label2);
			destroy_component(label3);
			destroy_component(label4);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GymSearch", slots, []);
	const dispatch = createEventDispatcher();
	let facilityList = gymCodes.getFacilityCodes();
	let gymSearchParams = {};
	let facilitiesCodes = [];

	function searchedPressed() {
		$$invalidate(1, facilitiesCodes = facilitiesCodes.map(item => item.code));

		$$invalidate(0, gymSearchParams = {
			...gymSearchParams,
			facilityCodes: facilitiesCodes.join(",")
		});

		gymSearchResult.searchGyms(createQuery(gymSearchParams));
		dispatch("searchPressed", { pressed: true });
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GymSearch> was created with unknown prop '${key}'`);
	});

	function input_value_binding(value) {
		gymSearchParams.country = value;
		$$invalidate(0, gymSearchParams);
	}

	function input_value_binding_1(value) {
		gymSearchParams.city = value;
		$$invalidate(0, gymSearchParams);
	}

	function input0_value_binding(value) {
		gymSearchParams.minPrice = value;
		$$invalidate(0, gymSearchParams);
	}

	function input1_value_binding(value) {
		gymSearchParams.maxPrice = value;
		$$invalidate(0, gymSearchParams);
	}

	function input0_value_binding_1(value) {
		gymSearchParams.openBefore = value;
		$$invalidate(0, gymSearchParams);
	}

	function input1_value_binding_1(value) {
		gymSearchParams.openAfter = value;
		$$invalidate(0, gymSearchParams);
	}

	function select_change_handler() {
		facilitiesCodes = select_multiple_value(this);
		$$invalidate(1, facilitiesCodes);
		$$invalidate(3, facilityList);
	}

	$$self.$capture_state = () => ({
		Label,
		Input,
		gymCodes,
		createEventDispatcher,
		gymSearchResult,
		createQuery,
		dispatch,
		facilityList,
		gymSearchParams,
		facilitiesCodes,
		searchedPressed
	});

	$$self.$inject_state = $$props => {
		if ("facilityList" in $$props) $$invalidate(3, facilityList = $$props.facilityList);
		if ("gymSearchParams" in $$props) $$invalidate(0, gymSearchParams = $$props.gymSearchParams);
		if ("facilitiesCodes" in $$props) $$invalidate(1, facilitiesCodes = $$props.facilitiesCodes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		gymSearchParams,
		facilitiesCodes,
		searchedPressed,
		facilityList,
		input_value_binding,
		input_value_binding_1,
		input0_value_binding,
		input1_value_binding,
		input0_value_binding_1,
		input1_value_binding_1,
		select_change_handler
	];
}

class GymSearch extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GymSearch",
			options,
			id: create_fragment$4.name
		});
	}
}

/* src\components\Paper\Paper.svelte generated by Svelte v3.29.7 */

const file$5 = "src\\components\\Paper\\Paper.svelte";
const get_paperText_slot_changes = dirty => ({});
const get_paperText_slot_context = ctx => ({});
const get_paperTitle_slot_changes = dirty => ({});
const get_paperTitle_slot_context = ctx => ({});
const get_paperIcon_slot_changes = dirty => ({});
const get_paperIcon_slot_context = ctx => ({});

function create_fragment$5(ctx) {
	let div3;
	let div0;
	let t0;
	let div1;
	let t1;
	let div2;
	let current;
	const paperIcon_slot_template = /*#slots*/ ctx[1].paperIcon;
	const paperIcon_slot = create_slot(paperIcon_slot_template, ctx, /*$$scope*/ ctx[0], get_paperIcon_slot_context);
	const paperTitle_slot_template = /*#slots*/ ctx[1].paperTitle;
	const paperTitle_slot = create_slot(paperTitle_slot_template, ctx, /*$$scope*/ ctx[0], get_paperTitle_slot_context);
	const paperText_slot_template = /*#slots*/ ctx[1].paperText;
	const paperText_slot = create_slot(paperText_slot_template, ctx, /*$$scope*/ ctx[0], get_paperText_slot_context);

	const block = {
		c: function create() {
			div3 = element("div");
			div0 = element("div");
			if (paperIcon_slot) paperIcon_slot.c();
			t0 = space();
			div1 = element("div");
			if (paperTitle_slot) paperTitle_slot.c();
			t1 = space();
			div2 = element("div");
			if (paperText_slot) paperText_slot.c();
			attr_dev(div0, "class", "paperIcon svelte-11hfxxj");
			add_location(div0, file$5, 50, 2, 954);
			attr_dev(div1, "class", "paperTitle svelte-11hfxxj");
			add_location(div1, file$5, 53, 2, 1024);
			attr_dev(div2, "class", "paperText svelte-11hfxxj");
			add_location(div2, file$5, 56, 2, 1096);
			attr_dev(div3, "class", "paperContainer svelte-11hfxxj");
			add_location(div3, file$5, 49, 0, 923);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div0);

			if (paperIcon_slot) {
				paperIcon_slot.m(div0, null);
			}

			append_dev(div3, t0);
			append_dev(div3, div1);

			if (paperTitle_slot) {
				paperTitle_slot.m(div1, null);
			}

			append_dev(div3, t1);
			append_dev(div3, div2);

			if (paperText_slot) {
				paperText_slot.m(div2, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (paperIcon_slot) {
				if (paperIcon_slot.p && dirty & /*$$scope*/ 1) {
					update_slot(paperIcon_slot, paperIcon_slot_template, ctx, /*$$scope*/ ctx[0], dirty, get_paperIcon_slot_changes, get_paperIcon_slot_context);
				}
			}

			if (paperTitle_slot) {
				if (paperTitle_slot.p && dirty & /*$$scope*/ 1) {
					update_slot(paperTitle_slot, paperTitle_slot_template, ctx, /*$$scope*/ ctx[0], dirty, get_paperTitle_slot_changes, get_paperTitle_slot_context);
				}
			}

			if (paperText_slot) {
				if (paperText_slot.p && dirty & /*$$scope*/ 1) {
					update_slot(paperText_slot, paperText_slot_template, ctx, /*$$scope*/ ctx[0], dirty, get_paperText_slot_changes, get_paperText_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(paperIcon_slot, local);
			transition_in(paperTitle_slot, local);
			transition_in(paperText_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(paperIcon_slot, local);
			transition_out(paperTitle_slot, local);
			transition_out(paperText_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			if (paperIcon_slot) paperIcon_slot.d(detaching);
			if (paperTitle_slot) paperTitle_slot.d(detaching);
			if (paperText_slot) paperText_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Paper", slots, ['paperIcon','paperTitle','paperText']);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Paper> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class Paper extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Paper",
			options,
			id: create_fragment$5.name
		});
	}
}

/* src\components\Tag\Tag.svelte generated by Svelte v3.29.7 */

const file$6 = "src\\components\\Tag\\Tag.svelte";

function create_fragment$6(ctx) {
	let div;
	let span;
	let t0;
	let t1;
	let div_tilte_value;

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			t0 = text(/*title*/ ctx[0]);
			t1 = text(" +");
			set_style(span, "font-size", "smaller");
			add_location(span, file$6, 26, 1, 470);
			attr_dev(div, "class", "cardTag svelte-jjdcd9");
			attr_dev(div, "tilte", div_tilte_value = /*tooltip*/ ctx[1] || /*title*/ ctx[0]);
			add_location(div, file$6, 25, 0, 421);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			append_dev(span, t0);
			append_dev(span, t1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*title*/ 1) set_data_dev(t0, /*title*/ ctx[0]);

			if (dirty & /*tooltip, title*/ 3 && div_tilte_value !== (div_tilte_value = /*tooltip*/ ctx[1] || /*title*/ ctx[0])) {
				attr_dev(div, "tilte", div_tilte_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Tag", slots, []);
	let { title = "" } = $$props;
	let { tooltip = null } = $$props;
	const writable_props = ["title", "tooltip"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tag> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("tooltip" in $$props) $$invalidate(1, tooltip = $$props.tooltip);
	};

	$$self.$capture_state = () => ({ title, tooltip });

	$$self.$inject_state = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("tooltip" in $$props) $$invalidate(1, tooltip = $$props.tooltip);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [title, tooltip];
}

class Tag extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { title: 0, tooltip: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tag",
			options,
			id: create_fragment$6.name
		});
	}

	get title() {
		throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\Card\Card.svelte generated by Svelte v3.29.7 */
const file$7 = "src\\components\\Card\\Card.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[20] = list[i];
	child_ctx[22] = i;
	return child_ctx;
}

// (164:20) {#if index < 4}
function create_if_block_5(ctx) {
	let tag;
	let current;

	tag = new Tag({
			props: {
				title: /*facility*/ ctx[20].customName || /*facility*/ ctx[20].facilityCode.name,
				tooltip: /*facility*/ ctx[20].description
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(tag.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(tag, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const tag_changes = {};
			if (dirty & /*facilities*/ 2048) tag_changes.title = /*facility*/ ctx[20].customName || /*facility*/ ctx[20].facilityCode.name;
			if (dirty & /*facilities*/ 2048) tag_changes.tooltip = /*facility*/ ctx[20].description;
			tag.$set(tag_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tag.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tag.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(tag, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(164:20) {#if index < 4}",
		ctx
	});

	return block;
}

// (163:16) {#each facilities as facility, index}
function create_each_block$1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*index*/ ctx[22] < 4 && create_if_block_5(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*index*/ ctx[22] < 4) if_block.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(163:16) {#each facilities as facility, index}",
		ctx
	});

	return block;
}

// (173:12) {#if facebookUserId}
function create_if_block_4(ctx) {
	let a;
	let img;
	let img_title_value;
	let img_src_value;
	let img_alt_value;
	let a_href_value;

	const block = {
		c: function create() {
			a = element("a");
			img = element("img");
			attr_dev(img, "title", img_title_value = "facebook");
			attr_dev(img, "class", "socialMedia svelte-y8er3h");
			if (img.src !== (img_src_value = "https://www.flaticon.com/svg/vstatic/svg/1384/1384053.svg?token=exp=1613758055~hmac=08ad0f0238024287f488ebca6a2ee284")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = "facebook");
			attr_dev(img, "target", "_blank");
			add_location(img, file$7, 174, 20, 4983);
			attr_dev(a, "href", a_href_value = `http://www.facebook.com/${/*facebookUserId*/ ctx[5]}`);
			add_location(a, file$7, 173, 16, 4907);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, img);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*facebookUserId*/ 32 && a_href_value !== (a_href_value = `http://www.facebook.com/${/*facebookUserId*/ ctx[5]}`)) {
				attr_dev(a, "href", a_href_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(173:12) {#if facebookUserId}",
		ctx
	});

	return block;
}

// (178:12) {#if instagramUserId}
function create_if_block_3(ctx) {
	let a;
	let img;
	let img_title_value;
	let img_src_value;
	let img_alt_value;
	let a_href_value;

	const block = {
		c: function create() {
			a = element("a");
			img = element("img");
			attr_dev(img, "title", img_title_value = "instagram");
			attr_dev(img, "class", "socialMedia svelte-y8er3h");
			if (img.src !== (img_src_value = "https://image.flaticon.com/icons/png/128/174/174855.png")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = "instagram");
			attr_dev(img, "target", "_blank");
			add_location(img, file$7, 179, 20, 5362);
			attr_dev(a, "href", a_href_value = `http://www.instagram.com/${/*instagramUserId*/ ctx[6]}`);
			add_location(a, file$7, 178, 16, 5284);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, img);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*instagramUserId*/ 64 && a_href_value !== (a_href_value = `http://www.instagram.com/${/*instagramUserId*/ ctx[6]}`)) {
				attr_dev(a, "href", a_href_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(178:12) {#if instagramUserId}",
		ctx
	});

	return block;
}

// (183:12) {#if twitterUserId}
function create_if_block_2(ctx) {
	let a;
	let img;
	let img_title_value;
	let img_src_value;
	let img_alt_value;
	let a_href_value;

	const block = {
		c: function create() {
			a = element("a");
			img = element("img");
			attr_dev(img, "title", img_title_value = "twitter");
			attr_dev(img, "class", "socialMedia svelte-y8er3h");
			if (img.src !== (img_src_value = "https://www.flaticon.com/svg/vstatic/svg/733/733579.svg?token=exp=1613670201~hmac=7dc90efacbf4acff7d6c08ddeef04bac")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = "twitter");
			attr_dev(img, "target", "_blank");
			add_location(img, file$7, 184, 20, 5673);
			attr_dev(a, "href", a_href_value = `http://www.twitter.com/${/*twitterUserId*/ ctx[7]}`);
			add_location(a, file$7, 183, 16, 5599);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, img);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*twitterUserId*/ 128 && a_href_value !== (a_href_value = `http://www.twitter.com/${/*twitterUserId*/ ctx[7]}`)) {
				attr_dev(a, "href", a_href_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(183:12) {#if twitterUserId}",
		ctx
	});

	return block;
}

// (188:12) {#if youtubeUserId}
function create_if_block_1(ctx) {
	let a;
	let img;
	let img_title_value;
	let img_src_value;
	let img_alt_value;
	let a_href_value;

	const block = {
		c: function create() {
			a = element("a");
			img = element("img");
			attr_dev(img, "title", img_title_value = "youtube");
			attr_dev(img, "class", "socialMedia svelte-y8er3h");
			if (img.src !== (img_src_value = "https://www.flaticon.com/svg/vstatic/svg/1384/1384060.svg?token=exp=1613670277~hmac=423299d6c97e4f9c048d452c6d1ff16a")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = "youtube");
			attr_dev(img, "target", "_blank");
			add_location(img, file$7, 189, 20, 6043);
			attr_dev(a, "href", a_href_value = `http://www.youtube.com/${/*youtubeUserId*/ ctx[8]}`);
			add_location(a, file$7, 188, 16, 5969);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, img);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*youtubeUserId*/ 256 && a_href_value !== (a_href_value = `http://www.youtube.com/${/*youtubeUserId*/ ctx[8]}`)) {
				attr_dev(a, "href", a_href_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(188:12) {#if youtubeUserId}",
		ctx
	});

	return block;
}

// (193:12) {#if webPageUserId}
function create_if_block$1(ctx) {
	let a;
	let img;
	let img_title_value;
	let img_src_value;
	let img_alt_value;

	const block = {
		c: function create() {
			a = element("a");
			img = element("img");
			attr_dev(img, "title", img_title_value = "website");
			attr_dev(img, "class", "socialMedia svelte-y8er3h");
			if (img.src !== (img_src_value = "https://icon-library.com/images/website-icon-png-transparent/website-icon-png-transparent-14.jpg")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = "website");
			attr_dev(img, "target", "_blank");
			add_location(img, file$7, 194, 20, 6387);
			attr_dev(a, "href", /*webPageUserId*/ ctx[9]);
			add_location(a, file$7, 193, 16, 6341);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, img);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*webPageUserId*/ 512) {
				attr_dev(a, "href", /*webPageUserId*/ ctx[9]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(193:12) {#if webPageUserId}",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let div15;
	let div10;
	let div1;
	let div0;
	let a;
	let t0;
	let a_href_value;
	let t1;
	let div2;
	let t2;
	let t3;
	let t4;
	let t5;
	let div3;
	let t6;
	let t7;
	let div9;
	let div7;
	let div4;
	let span0;
	let t9;
	let span1;
	let t11;
	let span2;
	let t13;
	let span3;
	let t15;
	let div5;
	let span4;
	let t17;
	let span5;
	let t18;
	let t19;
	let t20;
	let t21;
	let div6;
	let span6;
	let t23;
	let span7;
	let t24;
	let t25;
	let t26;
	let t27;
	let div8;
	let t28;
	let div12;
	let div11;
	let t29;
	let t30;
	let t31;
	let t32;
	let t33;
	let div14;
	let div13;
	let img;
	let img_src_value;
	let img_alt_value;
	let current;
	let mounted;
	let dispose;
	let each_value = /*facilities*/ ctx[11];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block0 = /*facebookUserId*/ ctx[5] && create_if_block_4(ctx);
	let if_block1 = /*instagramUserId*/ ctx[6] && create_if_block_3(ctx);
	let if_block2 = /*twitterUserId*/ ctx[7] && create_if_block_2(ctx);
	let if_block3 = /*youtubeUserId*/ ctx[8] && create_if_block_1(ctx);
	let if_block4 = /*webPageUserId*/ ctx[9] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			div15 = element("div");
			div10 = element("div");
			div1 = element("div");
			div0 = element("div");
			a = element("a");
			t0 = text(/*name*/ ctx[1]);
			t1 = space();
			div2 = element("div");
			t2 = text(/*phone*/ ctx[4]);
			t3 = space();
			t4 = text(/*address*/ ctx[3]);
			t5 = space();
			div3 = element("div");
			t6 = text(/*shortDesc*/ ctx[2]);
			t7 = space();
			div9 = element("div");
			div7 = element("div");
			div4 = element("div");
			span0 = element("span");
			span0.textContent = "★";
			t9 = space();
			span1 = element("span");
			span1.textContent = "★";
			t11 = space();
			span2 = element("span");
			span2.textContent = "★";
			t13 = space();
			span3 = element("span");
			span3.textContent = "★";
			t15 = space();
			div5 = element("div");
			span4 = element("span");
			span4.textContent = "$";
			t17 = space();
			span5 = element("span");
			t18 = text(/*minPrice*/ ctx[12]);
			t19 = text("- ");
			t20 = text(/*maxPrice*/ ctx[13]);
			t21 = space();
			div6 = element("div");
			span6 = element("span");
			span6.textContent = "🕓";
			t23 = space();
			span7 = element("span");
			t24 = text(/*earliestOpening*/ ctx[14]);
			t25 = text("- ");
			t26 = text(/*latestClosing*/ ctx[15]);
			t27 = space();
			div8 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t28 = space();
			div12 = element("div");
			div11 = element("div");
			if (if_block0) if_block0.c();
			t29 = space();
			if (if_block1) if_block1.c();
			t30 = space();
			if (if_block2) if_block2.c();
			t31 = space();
			if (if_block3) if_block3.c();
			t32 = space();
			if (if_block4) if_block4.c();
			t33 = space();
			div14 = element("div");
			div13 = element("div");
			img = element("img");
			attr_dev(a, "href", a_href_value = /*$url*/ ctx[16](`gym/${/*id*/ ctx[0]}`));
			attr_dev(a, "title", /*name*/ ctx[1]);
			add_location(a, file$7, 131, 20, 3259);
			attr_dev(div0, "class", "cardTitle svelte-y8er3h");
			add_location(div0, file$7, 130, 16, 3195);
			attr_dev(div1, "class", "cardHeader svelte-y8er3h");
			add_location(div1, file$7, 129, 12, 3153);
			attr_dev(div2, "class", "cardPhoneAndAddress svelte-y8er3h");
			add_location(div2, file$7, 134, 12, 3368);
			attr_dev(div3, "title", /*shortDesc*/ ctx[2]);
			attr_dev(div3, "class", "cardShortDesc svelte-y8er3h");
			add_location(div3, file$7, 139, 8, 3493);
			set_style(span0, "color", "gold");
			add_location(span0, file$7, 145, 20, 3718);
			set_style(span1, "color", "gold");
			add_location(span1, file$7, 146, 20, 3779);
			set_style(span2, "color", "gold");
			add_location(span2, file$7, 147, 20, 3840);
			set_style(span3, "color", "gold");
			add_location(span3, file$7, 148, 20, 3901);
			attr_dev(div4, "class", "cardRating");
			add_location(div4, file$7, 144, 16, 3672);
			attr_dev(span4, "tilte", "Highest and lowest price");
			set_style(span4, "color", "maroon");
			add_location(span4, file$7, 151, 20, 4027);
			add_location(span5, file$7, 152, 20, 4124);
			attr_dev(div5, "class", "cardPrice");
			add_location(div5, file$7, 150, 16, 3982);
			add_location(span6, file$7, 157, 20, 4298);
			add_location(span7, file$7, 158, 20, 4342);
			attr_dev(div6, "class", "cardOpenHours");
			add_location(div6, file$7, 156, 16, 4249);
			attr_dev(div7, "class", "cardFooterTop svelte-y8er3h");
			add_location(div7, file$7, 143, 12, 3627);
			attr_dev(div8, "class", "cardFooterMid svelte-y8er3h");
			add_location(div8, file$7, 161, 12, 4447);
			attr_dev(div9, "class", "cardFooter");
			add_location(div9, file$7, 142, 8, 3589);
			attr_dev(div10, "class", "cardLeft svelte-y8er3h");
			add_location(div10, file$7, 128, 4, 3117);
			attr_dev(div11, "class", "socialMediaHolder");
			add_location(div11, file$7, 171, 8, 4824);
			attr_dev(div12, "class", "cardMid");
			add_location(div12, file$7, 170, 4, 4793);
			set_style(img, "border-top-right-radius", "5px");
			set_style(img, "border-bottom-right-radius", "5px");
			attr_dev(img, "class", "cardImage svelte-y8er3h");
			if (img.src !== (img_src_value = /*imgSrc*/ ctx[10])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = `An image of ${/*name*/ ctx[1]}`);
			add_location(img, file$7, 201, 12, 6722);
			attr_dev(div13, "class", "cardGalleryShow");
			add_location(div13, file$7, 200, 8, 6679);
			attr_dev(div14, "class", "cardRight svelte-y8er3h");
			add_location(div14, file$7, 199, 4, 6646);
			attr_dev(div15, "class", "card svelte-y8er3h");
			add_location(div15, file$7, 127, 0, 3093);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div15, anchor);
			append_dev(div15, div10);
			append_dev(div10, div1);
			append_dev(div1, div0);
			append_dev(div0, a);
			append_dev(a, t0);
			append_dev(div10, t1);
			append_dev(div10, div2);
			append_dev(div2, t2);
			append_dev(div2, t3);
			append_dev(div2, t4);
			append_dev(div10, t5);
			append_dev(div10, div3);
			append_dev(div3, t6);
			append_dev(div10, t7);
			append_dev(div10, div9);
			append_dev(div9, div7);
			append_dev(div7, div4);
			append_dev(div4, span0);
			append_dev(div4, t9);
			append_dev(div4, span1);
			append_dev(div4, t11);
			append_dev(div4, span2);
			append_dev(div4, t13);
			append_dev(div4, span3);
			append_dev(div7, t15);
			append_dev(div7, div5);
			append_dev(div5, span4);
			append_dev(div5, t17);
			append_dev(div5, span5);
			append_dev(span5, t18);
			append_dev(span5, t19);
			append_dev(span5, t20);
			append_dev(div7, t21);
			append_dev(div7, div6);
			append_dev(div6, span6);
			append_dev(div6, t23);
			append_dev(div6, span7);
			append_dev(span7, t24);
			append_dev(span7, t25);
			append_dev(span7, t26);
			append_dev(div9, t27);
			append_dev(div9, div8);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div8, null);
			}

			append_dev(div15, t28);
			append_dev(div15, div12);
			append_dev(div12, div11);
			if (if_block0) if_block0.m(div11, null);
			append_dev(div11, t29);
			if (if_block1) if_block1.m(div11, null);
			append_dev(div11, t30);
			if (if_block2) if_block2.m(div11, null);
			append_dev(div11, t31);
			if (if_block3) if_block3.m(div11, null);
			append_dev(div11, t32);
			if (if_block4) if_block4.m(div11, null);
			append_dev(div15, t33);
			append_dev(div15, div14);
			append_dev(div14, div13);
			append_dev(div13, img);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div0, "click", /*forward*/ ctx[17], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*name*/ 2) set_data_dev(t0, /*name*/ ctx[1]);

			if (!current || dirty & /*$url, id*/ 65537 && a_href_value !== (a_href_value = /*$url*/ ctx[16](`gym/${/*id*/ ctx[0]}`))) {
				attr_dev(a, "href", a_href_value);
			}

			if (!current || dirty & /*name*/ 2) {
				attr_dev(a, "title", /*name*/ ctx[1]);
			}

			if (!current || dirty & /*phone*/ 16) set_data_dev(t2, /*phone*/ ctx[4]);
			if (!current || dirty & /*address*/ 8) set_data_dev(t4, /*address*/ ctx[3]);
			if (!current || dirty & /*shortDesc*/ 4) set_data_dev(t6, /*shortDesc*/ ctx[2]);

			if (!current || dirty & /*shortDesc*/ 4) {
				attr_dev(div3, "title", /*shortDesc*/ ctx[2]);
			}

			if (!current || dirty & /*minPrice*/ 4096) set_data_dev(t18, /*minPrice*/ ctx[12]);
			if (!current || dirty & /*maxPrice*/ 8192) set_data_dev(t20, /*maxPrice*/ ctx[13]);
			if (!current || dirty & /*earliestOpening*/ 16384) set_data_dev(t24, /*earliestOpening*/ ctx[14]);
			if (!current || dirty & /*latestClosing*/ 32768) set_data_dev(t26, /*latestClosing*/ ctx[15]);

			if (dirty & /*facilities*/ 2048) {
				each_value = /*facilities*/ ctx[11];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div8, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (/*facebookUserId*/ ctx[5]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					if_block0.m(div11, t29);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*instagramUserId*/ ctx[6]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					if_block1.m(div11, t30);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*twitterUserId*/ ctx[7]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_2(ctx);
					if_block2.c();
					if_block2.m(div11, t31);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*youtubeUserId*/ ctx[8]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_1(ctx);
					if_block3.c();
					if_block3.m(div11, t32);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (/*webPageUserId*/ ctx[9]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block$1(ctx);
					if_block4.c();
					if_block4.m(div11, null);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (!current || dirty & /*imgSrc*/ 1024 && img.src !== (img_src_value = /*imgSrc*/ ctx[10])) {
				attr_dev(img, "src", img_src_value);
			}

			if (!current || dirty & /*name*/ 2 && img_alt_value !== (img_alt_value = `An image of ${/*name*/ ctx[1]}`)) {
				attr_dev(img, "alt", img_alt_value);
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div15);
			destroy_each(each_blocks, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let $url;
	validate_store(url, "url");
	component_subscribe($$self, url, $$value => $$invalidate(16, $url = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Card", slots, []);
	let dispatch = createEventDispatcher();
	let { id } = $$props;
	let { type } = $$props;
	let { name } = $$props;
	let { shortDesc } = $$props;
	let { address = null } = $$props;
	let { phone = null } = $$props;
	let { facebookUserId = null } = $$props;
	let { instagramUserId = null } = $$props;
	let { twitterUserId = null } = $$props;
	let { youtubeUserId = null } = $$props;
	let { webPageUserId = null } = $$props;
	let { imgSrc = "" } = $$props;
	let { facilities = [] } = $$props;
	let { minPrice = null } = $$props;
	let { maxPrice = null } = $$props;
	let { earliestOpening = null } = $$props;
	let { latestClosing = null } = $$props;

	function forward() {
		dispatch("forward", { id, type });
	}

	

	const writable_props = [
		"id",
		"type",
		"name",
		"shortDesc",
		"address",
		"phone",
		"facebookUserId",
		"instagramUserId",
		"twitterUserId",
		"youtubeUserId",
		"webPageUserId",
		"imgSrc",
		"facilities",
		"minPrice",
		"maxPrice",
		"earliestOpening",
		"latestClosing"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Card> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("type" in $$props) $$invalidate(18, type = $$props.type);
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("shortDesc" in $$props) $$invalidate(2, shortDesc = $$props.shortDesc);
		if ("address" in $$props) $$invalidate(3, address = $$props.address);
		if ("phone" in $$props) $$invalidate(4, phone = $$props.phone);
		if ("facebookUserId" in $$props) $$invalidate(5, facebookUserId = $$props.facebookUserId);
		if ("instagramUserId" in $$props) $$invalidate(6, instagramUserId = $$props.instagramUserId);
		if ("twitterUserId" in $$props) $$invalidate(7, twitterUserId = $$props.twitterUserId);
		if ("youtubeUserId" in $$props) $$invalidate(8, youtubeUserId = $$props.youtubeUserId);
		if ("webPageUserId" in $$props) $$invalidate(9, webPageUserId = $$props.webPageUserId);
		if ("imgSrc" in $$props) $$invalidate(10, imgSrc = $$props.imgSrc);
		if ("facilities" in $$props) $$invalidate(11, facilities = $$props.facilities);
		if ("minPrice" in $$props) $$invalidate(12, minPrice = $$props.minPrice);
		if ("maxPrice" in $$props) $$invalidate(13, maxPrice = $$props.maxPrice);
		if ("earliestOpening" in $$props) $$invalidate(14, earliestOpening = $$props.earliestOpening);
		if ("latestClosing" in $$props) $$invalidate(15, latestClosing = $$props.latestClosing);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		url,
		Tag,
		dispatch,
		id,
		type,
		name,
		shortDesc,
		address,
		phone,
		facebookUserId,
		instagramUserId,
		twitterUserId,
		youtubeUserId,
		webPageUserId,
		imgSrc,
		facilities,
		minPrice,
		maxPrice,
		earliestOpening,
		latestClosing,
		forward,
		$url
	});

	$$self.$inject_state = $$props => {
		if ("dispatch" in $$props) dispatch = $$props.dispatch;
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("type" in $$props) $$invalidate(18, type = $$props.type);
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("shortDesc" in $$props) $$invalidate(2, shortDesc = $$props.shortDesc);
		if ("address" in $$props) $$invalidate(3, address = $$props.address);
		if ("phone" in $$props) $$invalidate(4, phone = $$props.phone);
		if ("facebookUserId" in $$props) $$invalidate(5, facebookUserId = $$props.facebookUserId);
		if ("instagramUserId" in $$props) $$invalidate(6, instagramUserId = $$props.instagramUserId);
		if ("twitterUserId" in $$props) $$invalidate(7, twitterUserId = $$props.twitterUserId);
		if ("youtubeUserId" in $$props) $$invalidate(8, youtubeUserId = $$props.youtubeUserId);
		if ("webPageUserId" in $$props) $$invalidate(9, webPageUserId = $$props.webPageUserId);
		if ("imgSrc" in $$props) $$invalidate(10, imgSrc = $$props.imgSrc);
		if ("facilities" in $$props) $$invalidate(11, facilities = $$props.facilities);
		if ("minPrice" in $$props) $$invalidate(12, minPrice = $$props.minPrice);
		if ("maxPrice" in $$props) $$invalidate(13, maxPrice = $$props.maxPrice);
		if ("earliestOpening" in $$props) $$invalidate(14, earliestOpening = $$props.earliestOpening);
		if ("latestClosing" in $$props) $$invalidate(15, latestClosing = $$props.latestClosing);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		id,
		name,
		shortDesc,
		address,
		phone,
		facebookUserId,
		instagramUserId,
		twitterUserId,
		youtubeUserId,
		webPageUserId,
		imgSrc,
		facilities,
		minPrice,
		maxPrice,
		earliestOpening,
		latestClosing,
		$url,
		forward,
		type
	];
}

class Card extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
			id: 0,
			type: 18,
			name: 1,
			shortDesc: 2,
			address: 3,
			phone: 4,
			facebookUserId: 5,
			instagramUserId: 6,
			twitterUserId: 7,
			youtubeUserId: 8,
			webPageUserId: 9,
			imgSrc: 10,
			facilities: 11,
			minPrice: 12,
			maxPrice: 13,
			earliestOpening: 14,
			latestClosing: 15
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Card",
			options,
			id: create_fragment$7.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*id*/ ctx[0] === undefined && !("id" in props)) {
			console.warn("<Card> was created without expected prop 'id'");
		}

		if (/*type*/ ctx[18] === undefined && !("type" in props)) {
			console.warn("<Card> was created without expected prop 'type'");
		}

		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
			console.warn("<Card> was created without expected prop 'name'");
		}

		if (/*shortDesc*/ ctx[2] === undefined && !("shortDesc" in props)) {
			console.warn("<Card> was created without expected prop 'shortDesc'");
		}
	}

	get id() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get shortDesc() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set shortDesc(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get address() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set address(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get phone() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set phone(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get facebookUserId() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set facebookUserId(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instagramUserId() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set instagramUserId(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get twitterUserId() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set twitterUserId(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get youtubeUserId() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set youtubeUserId(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get webPageUserId() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set webPageUserId(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get imgSrc() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set imgSrc(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get facilities() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set facilities(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get minPrice() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set minPrice(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get maxPrice() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set maxPrice(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get earliestOpening() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set earliestOpening(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get latestClosing() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set latestClosing(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\FilterBar\FilterBar.svelte generated by Svelte v3.29.7 */

const file$8 = "src\\components\\FilterBar\\FilterBar.svelte";

// (85:65) 
function create_if_block_1$1(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "class", "sortImg svelte-16eny3j");
			if (img.src !== (img_src_value = "https://www.flaticon.com/svg/vstatic/svg/31/31013.svg?token=exp=1613914434~hmac=3bdddb403a9b013412820183a1afbb74")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "sortDesc");
			add_location(img, file$8, 85, 6, 2468);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);

			if (!mounted) {
				dispose = listen_dev(img, "click", /*sortMethodChange*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(85:65) ",
		ctx
	});

	return block;
}

// (83:4) {#if queryOptions.sortByMethod.toUpperCase() === 'ASC'}
function create_if_block$2(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "class", "sortImg svelte-16eny3j");
			if (img.src !== (img_src_value = "https://www.flaticon.com/svg/vstatic/svg/31/31283.svg?token=exp=1613914434~hmac=cef94f01e96f64b08c3a6dd8353cf470")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "sortAsc");
			add_location(img, file$8, 83, 6, 2210);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);

			if (!mounted) {
				dispose = listen_dev(img, "click", /*sortMethodChange*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(83:4) {#if queryOptions.sortByMethod.toUpperCase() === 'ASC'}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let div4;
	let div2;
	let div0;
	let t0;
	let t1;
	let t2;
	let div1;
	let t5;
	let div3;
	let dropdown0;
	let updating_selected;
	let t6;
	let dropdown1;
	let updating_selected_1;
	let t7;
	let show_if;
	let show_if_1;
	let current;

	function dropdown0_selected_binding(value) {
		/*dropdown0_selected_binding*/ ctx[8].call(null, value);
	}

	let dropdown0_props = {
		items: /*displayOptions*/ ctx[5],
		icon: "https://www.flaticon.com/svg/vstatic/svg/238/238910.svg?token=exp=1613760807~hmac=ef7a1d26886bda9164e4e5bb85c560a5"
	};

	if (/*selectedDisplay*/ ctx[3] !== void 0) {
		dropdown0_props.selected = /*selectedDisplay*/ ctx[3];
	}

	dropdown0 = new DropdownSingle({ props: dropdown0_props, $$inline: true });
	binding_callbacks.push(() => bind(dropdown0, "selected", dropdown0_selected_binding));

	function dropdown1_selected_binding(value) {
		/*dropdown1_selected_binding*/ ctx[9].call(null, value);
	}

	let dropdown1_props = { items: /*sortItems*/ ctx[4] };

	if (/*selectedSort*/ ctx[2] !== void 0) {
		dropdown1_props.selected = /*selectedSort*/ ctx[2];
	}

	dropdown1 = new DropdownSingle({ props: dropdown1_props, $$inline: true });
	binding_callbacks.push(() => bind(dropdown1, "selected", dropdown1_selected_binding));
	dropdown1.$on("itemChanged", /*sortChange*/ ctx[6]);

	function select_block_type(ctx, dirty) {
		if (show_if == null || dirty & /*queryOptions*/ 2) show_if = !!(/*queryOptions*/ ctx[1].sortByMethod.toUpperCase() === "ASC");
		if (show_if) return create_if_block$2;
		if (show_if_1 == null || dirty & /*queryOptions*/ 2) show_if_1 = !!(/*queryOptions*/ ctx[1].sortByMethod.toUpperCase() === "DESC");
		if (show_if_1) return create_if_block_1$1;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type && current_block_type(ctx);

	const block = {
		c: function create() {
			div4 = element("div");
			div2 = element("div");
			div0 = element("div");
			t0 = text("Result: ");
			t1 = text(/*found*/ ctx[0]);
			t2 = space();
			div1 = element("div");
			div1.textContent = `Item limit per page: ${pageSize}`;
			t5 = space();
			div3 = element("div");
			create_component(dropdown0.$$.fragment);
			t6 = space();
			create_component(dropdown1.$$.fragment);
			t7 = space();
			if (if_block) if_block.c();
			add_location(div0, file$8, 76, 4, 1743);
			add_location(div1, file$8, 77, 4, 1774);
			attr_dev(div2, "class", "filterBarLeft svelte-16eny3j");
			add_location(div2, file$8, 75, 2, 1711);
			attr_dev(div3, "class", "filterBarRight svelte-16eny3j");
			add_location(div3, file$8, 79, 2, 1828);
			attr_dev(div4, "class", "filterBarContainer svelte-16eny3j");
			add_location(div4, file$8, 74, 0, 1676);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div2);
			append_dev(div2, div0);
			append_dev(div0, t0);
			append_dev(div0, t1);
			append_dev(div2, t2);
			append_dev(div2, div1);
			append_dev(div4, t5);
			append_dev(div4, div3);
			mount_component(dropdown0, div3, null);
			append_dev(div3, t6);
			mount_component(dropdown1, div3, null);
			append_dev(div3, t7);
			if (if_block) if_block.m(div3, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*found*/ 1) set_data_dev(t1, /*found*/ ctx[0]);
			const dropdown0_changes = {};
			if (dirty & /*displayOptions*/ 32) dropdown0_changes.items = /*displayOptions*/ ctx[5];

			if (!updating_selected && dirty & /*selectedDisplay*/ 8) {
				updating_selected = true;
				dropdown0_changes.selected = /*selectedDisplay*/ ctx[3];
				add_flush_callback(() => updating_selected = false);
			}

			dropdown0.$set(dropdown0_changes);
			const dropdown1_changes = {};
			if (dirty & /*sortItems*/ 16) dropdown1_changes.items = /*sortItems*/ ctx[4];

			if (!updating_selected_1 && dirty & /*selectedSort*/ 4) {
				updating_selected_1 = true;
				dropdown1_changes.selected = /*selectedSort*/ ctx[2];
				add_flush_callback(() => updating_selected_1 = false);
			}

			dropdown1.$set(dropdown1_changes);

			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div3, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dropdown0.$$.fragment, local);
			transition_in(dropdown1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dropdown0.$$.fragment, local);
			transition_out(dropdown1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
			destroy_component(dropdown0);
			destroy_component(dropdown1);

			if (if_block) {
				if_block.d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("FilterBar", slots, []);
	let { found = null } = $$props;
	let selectedSort = queryOptions.sortByProperty;
	let selectedDisplay;

	function sortChange(event) {
		$$invalidate(1, queryOptions.sortByProperty = event.detail.selected, queryOptions);
		gymSearchResult.searchGyms(createQuery(searchForm));
	}

	function sortMethodChange() {
		if (queryOptions.sortByMethod === "ASC") {
			$$invalidate(1, queryOptions.sortByMethod = "DESC", queryOptions);
			gymSearchResult.searchGyms(createQuery(searchForm));
		} else if (queryOptions.sortByMethod === "DESC") {
			$$invalidate(1, queryOptions.sortByMethod = "ASC", queryOptions);
			gymSearchResult.searchGyms(createQuery(searchForm));
		}
	}

	const writable_props = ["found"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FilterBar> was created with unknown prop '${key}'`);
	});

	function dropdown0_selected_binding(value) {
		selectedDisplay = value;
		$$invalidate(3, selectedDisplay);
	}

	function dropdown1_selected_binding(value) {
		selectedSort = value;
		$$invalidate(2, selectedSort);
	}

	$$self.$$set = $$props => {
		if ("found" in $$props) $$invalidate(0, found = $$props.found);
	};

	$$self.$capture_state = () => ({
		Dropdown: DropdownSingle,
		gymSearchResult,
		queryOptions,
		searchForm,
		createQuery,
		pageSize,
		found,
		selectedSort,
		selectedDisplay,
		sortChange,
		sortMethodChange,
		sortItems,
		displayOptions
	});

	$$self.$inject_state = $$props => {
		if ("found" in $$props) $$invalidate(0, found = $$props.found);
		if ("selectedSort" in $$props) $$invalidate(2, selectedSort = $$props.selectedSort);
		if ("selectedDisplay" in $$props) $$invalidate(3, selectedDisplay = $$props.selectedDisplay);
		if ("sortItems" in $$props) $$invalidate(4, sortItems = $$props.sortItems);
		if ("displayOptions" in $$props) $$invalidate(5, displayOptions = $$props.displayOptions);
	};

	let sortItems;
	let displayOptions;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	 $$invalidate(4, sortItems = [
		{
			value: "averagePrice",
			label: "Order by price"
		},
		{ value: "name", label: "Order by name" },
		{
			value: "opening",
			label: "Order by opening"
		},
		{
			value: "location",
			label: "Order by location"
		}
	]);

	 $$invalidate(5, displayOptions = [{ value: 1, label: "List view" }, { value: 2, label: "Grid view" }]);

	return [
		found,
		queryOptions,
		selectedSort,
		selectedDisplay,
		sortItems,
		displayOptions,
		sortChange,
		sortMethodChange,
		dropdown0_selected_binding,
		dropdown1_selected_binding
	];
}

class FilterBar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { found: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FilterBar",
			options,
			id: create_fragment$8.name
		});
	}

	get found() {
		throw new Error("<FilterBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set found(value) {
		throw new Error("<FilterBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\pages\index.svelte generated by Svelte v3.29.7 */

const { console: console_1 } = globals;
const file$9 = "src\\pages\\index.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	return child_ctx;
}

// (70:14) <Tab>
function create_default_slot_11(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("GYM search");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11.name,
		type: "slot",
		source: "(70:14) <Tab>",
		ctx
	});

	return block;
}

// (73:14) <Tab>
function create_default_slot_10(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("PT search");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10.name,
		type: "slot",
		source: "(73:14) <Tab>",
		ctx
	});

	return block;
}

// (69:12) <TabList>
function create_default_slot_9(ctx) {
	let tab0;
	let t;
	let tab1;
	let current;

	tab0 = new Tab({
			props: {
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	tab1 = new Tab({
			props: {
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(tab0.$$.fragment);
			t = space();
			create_component(tab1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(tab0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(tab1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const tab0_changes = {};

			if (dirty & /*$$scope*/ 64) {
				tab0_changes.$$scope = { dirty, ctx };
			}

			tab0.$set(tab0_changes);
			const tab1_changes = {};

			if (dirty & /*$$scope*/ 64) {
				tab1_changes.$$scope = { dirty, ctx };
			}

			tab1.$set(tab1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tab0.$$.fragment, local);
			transition_in(tab1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tab0.$$.fragment, local);
			transition_out(tab1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(tab0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(tab1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(69:12) <TabList>",
		ctx
	});

	return block;
}

// (77:12) <TabPanel>
function create_default_slot_8(ctx) {
	let gymsearch;
	let current;
	gymsearch = new GymSearch({ $$inline: true });
	gymsearch.$on("searchPressed", /*handleSearchPressed*/ ctx[2]);

	const block = {
		c: function create() {
			create_component(gymsearch.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(gymsearch, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(gymsearch.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(gymsearch.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(gymsearch, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(77:12) <TabPanel>",
		ctx
	});

	return block;
}

// (80:12) <TabPanel>
function create_default_slot_7(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("PT SEARCH CONTENT COMES HERE");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(80:12) <TabPanel>",
		ctx
	});

	return block;
}

// (68:10) <Tabs>
function create_default_slot_6(ctx) {
	let tablist;
	let t0;
	let tabpanel0;
	let t1;
	let tabpanel1;
	let current;

	tablist = new TabList({
			props: {
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	tabpanel0 = new TabPanel({
			props: {
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	tabpanel1 = new TabPanel({
			props: {
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(tablist.$$.fragment);
			t0 = space();
			create_component(tabpanel0.$$.fragment);
			t1 = space();
			create_component(tabpanel1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(tablist, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(tabpanel0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(tabpanel1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const tablist_changes = {};

			if (dirty & /*$$scope*/ 64) {
				tablist_changes.$$scope = { dirty, ctx };
			}

			tablist.$set(tablist_changes);
			const tabpanel0_changes = {};

			if (dirty & /*$$scope*/ 64) {
				tabpanel0_changes.$$scope = { dirty, ctx };
			}

			tabpanel0.$set(tabpanel0_changes);
			const tabpanel1_changes = {};

			if (dirty & /*$$scope*/ 64) {
				tabpanel1_changes.$$scope = { dirty, ctx };
			}

			tabpanel1.$set(tabpanel1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tablist.$$.fragment, local);
			transition_in(tabpanel0.$$.fragment, local);
			transition_in(tabpanel1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tablist.$$.fragment, local);
			transition_out(tabpanel0.$$.fragment, local);
			transition_out(tabpanel1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(tablist, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(tabpanel0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(tabpanel1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(68:10) <Tabs>",
		ctx
	});

	return block;
}

// (98:8) {#if $gymSearchResult.gyms.length >= 1}
function create_if_block_1$2(ctx) {
	let filterbar;
	let t;
	let each_1_anchor;
	let current;

	filterbar = new FilterBar({
			props: {
				type: "GYM",
				found: /*$gymSearchResult*/ ctx[1].count
			},
			$$inline: true
		});

	let each_value = /*$gymSearchResult*/ ctx[1].gyms;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			create_component(filterbar.$$.fragment);
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			mount_component(filterbar, target, anchor);
			insert_dev(target, t, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const filterbar_changes = {};
			if (dirty & /*$gymSearchResult*/ 2) filterbar_changes.found = /*$gymSearchResult*/ ctx[1].count;
			filterbar.$set(filterbar_changes);

			if (dirty & /*$gymSearchResult*/ 2) {
				each_value = /*$gymSearchResult*/ ctx[1].gyms;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(filterbar.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(filterbar.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(filterbar, detaching);
			if (detaching) detach_dev(t);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(98:8) {#if $gymSearchResult.gyms.length >= 1}",
		ctx
	});

	return block;
}

// (86:6) {#if !searchPressed && $gymSearchResult.gyms.length === 0}
function create_if_block$3(ctx) {
	let paper0;
	let t;
	let paper1;
	let current;

	paper0 = new Paper({
			props: {
				$$slots: {
					default: [create_default_slot_5],
					paperText: [create_paperText_slot_5],
					paperTitle: [create_paperTitle_slot_5],
					paperIcon: [create_paperIcon_slot_5]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	paper1 = new Paper({
			props: {
				$$slots: {
					default: [create_default_slot_4$1],
					paperText: [create_paperText_slot_4],
					paperTitle: [create_paperTitle_slot_4],
					paperIcon: [create_paperIcon_slot_4]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(paper0.$$.fragment);
			t = space();
			create_component(paper1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(paper0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(paper1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const paper0_changes = {};

			if (dirty & /*$$scope*/ 64) {
				paper0_changes.$$scope = { dirty, ctx };
			}

			paper0.$set(paper0_changes);
			const paper1_changes = {};

			if (dirty & /*$$scope*/ 64) {
				paper1_changes.$$scope = { dirty, ctx };
			}

			paper1.$set(paper1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(paper0.$$.fragment, local);
			transition_in(paper1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(paper0.$$.fragment, local);
			transition_out(paper1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(paper0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(paper1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(86:6) {#if !searchPressed && $gymSearchResult.gyms.length === 0}",
		ctx
	});

	return block;
}

// (103:12) {#each $gymSearchResult.gyms as gym}
function create_each_block$2(ctx) {
	let card;
	let current;

	card = new Card({
			props: {
				id: /*gym*/ ctx[3].id,
				name: /*gym*/ ctx[3].name,
				type: "gym",
				phone: /*gym*/ ctx[3].phone,
				imgSrc: "https://www.cutlerzalaegerszeg.hu/index_htm_files/12785@2x.jpg",
				maxPrice: /*gym*/ ctx[3].maxPrice,
				minPrice: /*gym*/ ctx[3].minPrice,
				earliestOpening: /*gym*/ ctx[3].earliestOpening,
				latestClosing: /*gym*/ ctx[3].latestClosing,
				address: /*gym*/ ctx[3].addressString,
				shortDesc: /*gym*/ ctx[3].shortDescription,
				facebookUserId: /*gym*/ ctx[3].facebookUserId,
				instagramUserId: /*gym*/ ctx[3].instagramUserId,
				twitterUserId: /*gym*/ ctx[3].twitterUserId,
				youtubeUserId: /*gym*/ ctx[3].youtubeUserId,
				webPageUserId: /*gym*/ ctx[3].webPageUserId,
				facilities: /*gym*/ ctx[3].facilities
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(card.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const card_changes = {};
			if (dirty & /*$gymSearchResult*/ 2) card_changes.id = /*gym*/ ctx[3].id;
			if (dirty & /*$gymSearchResult*/ 2) card_changes.name = /*gym*/ ctx[3].name;
			if (dirty & /*$gymSearchResult*/ 2) card_changes.phone = /*gym*/ ctx[3].phone;
			if (dirty & /*$gymSearchResult*/ 2) card_changes.maxPrice = /*gym*/ ctx[3].maxPrice;
			if (dirty & /*$gymSearchResult*/ 2) card_changes.minPrice = /*gym*/ ctx[3].minPrice;
			if (dirty & /*$gymSearchResult*/ 2) card_changes.earliestOpening = /*gym*/ ctx[3].earliestOpening;
			if (dirty & /*$gymSearchResult*/ 2) card_changes.latestClosing = /*gym*/ ctx[3].latestClosing;
			if (dirty & /*$gymSearchResult*/ 2) card_changes.address = /*gym*/ ctx[3].addressString;
			if (dirty & /*$gymSearchResult*/ 2) card_changes.shortDesc = /*gym*/ ctx[3].shortDescription;
			if (dirty & /*$gymSearchResult*/ 2) card_changes.facebookUserId = /*gym*/ ctx[3].facebookUserId;
			if (dirty & /*$gymSearchResult*/ 2) card_changes.instagramUserId = /*gym*/ ctx[3].instagramUserId;
			if (dirty & /*$gymSearchResult*/ 2) card_changes.twitterUserId = /*gym*/ ctx[3].twitterUserId;
			if (dirty & /*$gymSearchResult*/ 2) card_changes.youtubeUserId = /*gym*/ ctx[3].youtubeUserId;
			if (dirty & /*$gymSearchResult*/ 2) card_changes.webPageUserId = /*gym*/ ctx[3].webPageUserId;
			if (dirty & /*$gymSearchResult*/ 2) card_changes.facilities = /*gym*/ ctx[3].facilities;
			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(card, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(103:12) {#each $gymSearchResult.gyms as gym}",
		ctx
	});

	return block;
}

// (88:10) <span slot="paperIcon">
function create_paperIcon_slot_5(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "💪";
			attr_dev(span, "slot", "paperIcon");
			add_location(span, file$9, 87, 10, 2412);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperIcon_slot_5.name,
		type: "slot",
		source: "(88:10) <span slot=\\\"paperIcon\\\">",
		ctx
	});

	return block;
}

// (89:10) <span slot="paperTitle">
function create_paperTitle_slot_5(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Best gyms";
			attr_dev(span, "slot", "paperTitle");
			add_location(span, file$9, 88, 10, 2462);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperTitle_slot_5.name,
		type: "slot",
		source: "(89:10) <span slot=\\\"paperTitle\\\">",
		ctx
	});

	return block;
}

// (90:10) <span slot="paperText">
function create_paperText_slot_5(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Find the best GYMs around you. Meet your requirements with our easy to use GYM finder";
			attr_dev(span, "slot", "paperText");
			add_location(span, file$9, 89, 10, 2513);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperText_slot_5.name,
		type: "slot",
		source: "(90:10) <span slot=\\\"paperText\\\">",
		ctx
	});

	return block;
}

// (87:8) <Paper>
function create_default_slot_5(ctx) {
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = space();
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(87:8) <Paper>",
		ctx
	});

	return block;
}

// (93:10) <span slot="paperIcon">
function create_paperIcon_slot_4(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "🏋";
			attr_dev(span, "slot", "paperIcon");
			add_location(span, file$9, 92, 10, 2672);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperIcon_slot_4.name,
		type: "slot",
		source: "(93:10) <span slot=\\\"paperIcon\\\">",
		ctx
	});

	return block;
}

// (94:10) <span slot="paperTitle">
function create_paperTitle_slot_4(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Best trainers";
			attr_dev(span, "slot", "paperTitle");
			add_location(span, file$9, 93, 10, 2722);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperTitle_slot_4.name,
		type: "slot",
		source: "(94:10) <span slot=\\\"paperTitle\\\">",
		ctx
	});

	return block;
}

// (95:10) <span slot="paperText">
function create_paperText_slot_4(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Find a professional with the right specializations that meet your goals. Get fit or rehabilitize we help you!";
			attr_dev(span, "slot", "paperText");
			add_location(span, file$9, 94, 10, 2777);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperText_slot_4.name,
		type: "slot",
		source: "(95:10) <span slot=\\\"paperText\\\">",
		ctx
	});

	return block;
}

// (92:8) <Paper>
function create_default_slot_4$1(ctx) {
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = space();
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$1.name,
		type: "slot",
		source: "(92:8) <Paper>",
		ctx
	});

	return block;
}

// (130:6) <span slot="paperIcon">
function create_paperIcon_slot_3(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "💪";
			attr_dev(span, "slot", "paperIcon");
			add_location(span, file$9, 129, 6, 4106);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperIcon_slot_3.name,
		type: "slot",
		source: "(130:6) <span slot=\\\"paperIcon\\\">",
		ctx
	});

	return block;
}

// (131:6) <span slot="paperTitle">
function create_paperTitle_slot_3(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Best gyms";
			attr_dev(span, "slot", "paperTitle");
			add_location(span, file$9, 130, 6, 4152);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperTitle_slot_3.name,
		type: "slot",
		source: "(131:6) <span slot=\\\"paperTitle\\\">",
		ctx
	});

	return block;
}

// (132:6) <span slot="paperText">
function create_paperText_slot_3(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Find the best GYMs around you. Meet your requirements with our easy to use GYM finder";
			attr_dev(span, "slot", "paperText");
			add_location(span, file$9, 131, 6, 4199);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperText_slot_3.name,
		type: "slot",
		source: "(132:6) <span slot=\\\"paperText\\\">",
		ctx
	});

	return block;
}

// (129:4) <Paper>
function create_default_slot_3$1(ctx) {
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = space();
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(129:4) <Paper>",
		ctx
	});

	return block;
}

// (135:6) <span slot="paperIcon">
function create_paperIcon_slot_2(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "💪";
			attr_dev(span, "slot", "paperIcon");
			add_location(span, file$9, 134, 6, 4346);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperIcon_slot_2.name,
		type: "slot",
		source: "(135:6) <span slot=\\\"paperIcon\\\">",
		ctx
	});

	return block;
}

// (136:6) <span slot="paperTitle">
function create_paperTitle_slot_2(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Best gyms";
			attr_dev(span, "slot", "paperTitle");
			add_location(span, file$9, 135, 6, 4392);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperTitle_slot_2.name,
		type: "slot",
		source: "(136:6) <span slot=\\\"paperTitle\\\">",
		ctx
	});

	return block;
}

// (137:6) <span slot="paperText">
function create_paperText_slot_2(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Find the best GYMs around you. Meet your requirements with our easy to use GYM finder";
			attr_dev(span, "slot", "paperText");
			add_location(span, file$9, 136, 6, 4439);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperText_slot_2.name,
		type: "slot",
		source: "(137:6) <span slot=\\\"paperText\\\">",
		ctx
	});

	return block;
}

// (134:4) <Paper>
function create_default_slot_2$1(ctx) {
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = space();
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(134:4) <Paper>",
		ctx
	});

	return block;
}

// (140:6) <span slot="paperIcon">
function create_paperIcon_slot_1(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "💪";
			attr_dev(span, "slot", "paperIcon");
			add_location(span, file$9, 139, 6, 4586);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperIcon_slot_1.name,
		type: "slot",
		source: "(140:6) <span slot=\\\"paperIcon\\\">",
		ctx
	});

	return block;
}

// (141:6) <span slot="paperTitle">
function create_paperTitle_slot_1(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Best gyms";
			attr_dev(span, "slot", "paperTitle");
			add_location(span, file$9, 140, 6, 4632);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperTitle_slot_1.name,
		type: "slot",
		source: "(141:6) <span slot=\\\"paperTitle\\\">",
		ctx
	});

	return block;
}

// (142:6) <span slot="paperText">
function create_paperText_slot_1(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Find the best GYMs around you. Meet your requirements with our easy to use GYM finder";
			attr_dev(span, "slot", "paperText");
			add_location(span, file$9, 141, 6, 4679);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperText_slot_1.name,
		type: "slot",
		source: "(142:6) <span slot=\\\"paperText\\\">",
		ctx
	});

	return block;
}

// (139:4) <Paper>
function create_default_slot_1$1(ctx) {
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = space();
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(139:4) <Paper>",
		ctx
	});

	return block;
}

// (145:6) <span slot="paperIcon">
function create_paperIcon_slot(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "💪";
			attr_dev(span, "slot", "paperIcon");
			add_location(span, file$9, 144, 6, 4826);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperIcon_slot.name,
		type: "slot",
		source: "(145:6) <span slot=\\\"paperIcon\\\">",
		ctx
	});

	return block;
}

// (146:6) <span slot="paperTitle">
function create_paperTitle_slot(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Best gyms";
			attr_dev(span, "slot", "paperTitle");
			add_location(span, file$9, 145, 6, 4872);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperTitle_slot.name,
		type: "slot",
		source: "(146:6) <span slot=\\\"paperTitle\\\">",
		ctx
	});

	return block;
}

// (147:6) <span slot="paperText">
function create_paperText_slot(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Find the best GYMs around you. Meet your requirements with our easy to use GYM finder";
			attr_dev(span, "slot", "paperText");
			add_location(span, file$9, 146, 6, 4919);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paperText_slot.name,
		type: "slot",
		source: "(147:6) <span slot=\\\"paperText\\\">",
		ctx
	});

	return block;
}

// (144:4) <Paper>
function create_default_slot$1(ctx) {
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = space();
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(144:4) <Paper>",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let div5;
	let div2;
	let div0;
	let tabs;
	let t0;
	let div1;
	let current_block_type_index;
	let if_block;
	let t1;
	let div3;
	let paper0;
	let t2;
	let paper1;
	let t3;
	let paper2;
	let t4;
	let paper3;
	let t5;
	let div4;
	let current;

	tabs = new Tabs({
			props: {
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block$3, create_if_block_1$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (!/*searchPressed*/ ctx[0] && /*$gymSearchResult*/ ctx[1].gyms.length === 0) return 0;
		if (/*$gymSearchResult*/ ctx[1].gyms.length >= 1) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	paper0 = new Paper({
			props: {
				$$slots: {
					default: [create_default_slot_3$1],
					paperText: [create_paperText_slot_3],
					paperTitle: [create_paperTitle_slot_3],
					paperIcon: [create_paperIcon_slot_3]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	paper1 = new Paper({
			props: {
				$$slots: {
					default: [create_default_slot_2$1],
					paperText: [create_paperText_slot_2],
					paperTitle: [create_paperTitle_slot_2],
					paperIcon: [create_paperIcon_slot_2]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	paper2 = new Paper({
			props: {
				$$slots: {
					default: [create_default_slot_1$1],
					paperText: [create_paperText_slot_1],
					paperTitle: [create_paperTitle_slot_1],
					paperIcon: [create_paperIcon_slot_1]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	paper3 = new Paper({
			props: {
				$$slots: {
					default: [create_default_slot$1],
					paperText: [create_paperText_slot],
					paperTitle: [create_paperTitle_slot],
					paperIcon: [create_paperIcon_slot]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div5 = element("div");
			div2 = element("div");
			div0 = element("div");
			create_component(tabs.$$.fragment);
			t0 = space();
			div1 = element("div");
			if (if_block) if_block.c();
			t1 = space();
			div3 = element("div");
			create_component(paper0.$$.fragment);
			t2 = space();
			create_component(paper1.$$.fragment);
			t3 = space();
			create_component(paper2.$$.fragment);
			t4 = space();
			create_component(paper3.$$.fragment);
			t5 = space();
			div4 = element("div");
			attr_dev(div0, "class", "searchTabs svelte-of0tm6");
			add_location(div0, file$9, 66, 6, 1820);
			attr_dev(div1, "class", "resultTabs scrollable svelte-of0tm6");
			add_location(div1, file$9, 84, 4, 2285);
			attr_dev(div2, "class", "searchAndResults svelte-of0tm6");
			add_location(div2, file$9, 65, 2, 1783);
			attr_dev(div3, "class", "marketingCards scrollable svelte-of0tm6");
			add_location(div3, file$9, 127, 2, 4048);
			attr_dev(div4, "class", "footer");
			add_location(div4, file$9, 149, 2, 5059);
			attr_dev(div5, "class", "homeContainer scrollable svelte-of0tm6");
			add_location(div5, file$9, 64, 0, 1742);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div2);
			append_dev(div2, div0);
			mount_component(tabs, div0, null);
			append_dev(div2, t0);
			append_dev(div2, div1);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div1, null);
			}

			append_dev(div5, t1);
			append_dev(div5, div3);
			mount_component(paper0, div3, null);
			append_dev(div3, t2);
			mount_component(paper1, div3, null);
			append_dev(div3, t3);
			mount_component(paper2, div3, null);
			append_dev(div3, t4);
			mount_component(paper3, div3, null);
			append_dev(div5, t5);
			append_dev(div5, div4);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const tabs_changes = {};

			if (dirty & /*$$scope*/ 64) {
				tabs_changes.$$scope = { dirty, ctx };
			}

			tabs.$set(tabs_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div1, null);
				} else {
					if_block = null;
				}
			}

			const paper0_changes = {};

			if (dirty & /*$$scope*/ 64) {
				paper0_changes.$$scope = { dirty, ctx };
			}

			paper0.$set(paper0_changes);
			const paper1_changes = {};

			if (dirty & /*$$scope*/ 64) {
				paper1_changes.$$scope = { dirty, ctx };
			}

			paper1.$set(paper1_changes);
			const paper2_changes = {};

			if (dirty & /*$$scope*/ 64) {
				paper2_changes.$$scope = { dirty, ctx };
			}

			paper2.$set(paper2_changes);
			const paper3_changes = {};

			if (dirty & /*$$scope*/ 64) {
				paper3_changes.$$scope = { dirty, ctx };
			}

			paper3.$set(paper3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tabs.$$.fragment, local);
			transition_in(if_block);
			transition_in(paper0.$$.fragment, local);
			transition_in(paper1.$$.fragment, local);
			transition_in(paper2.$$.fragment, local);
			transition_in(paper3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tabs.$$.fragment, local);
			transition_out(if_block);
			transition_out(paper0.$$.fragment, local);
			transition_out(paper1.$$.fragment, local);
			transition_out(paper2.$$.fragment, local);
			transition_out(paper3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			destroy_component(tabs);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			destroy_component(paper0);
			destroy_component(paper1);
			destroy_component(paper2);
			destroy_component(paper3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let $gymSearchResult;
	validate_store(gymSearchResult, "gymSearchResult");
	component_subscribe($$self, gymSearchResult, $$value => $$invalidate(1, $gymSearchResult = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Pages", slots, []);
	let searchPressed = false;

	function handleSearchPressed(event) {
		console.log(event.detail.pressed);
		$$invalidate(0, searchPressed = event.detail.pressed);
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Pages> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		NotificationDisplay,
		Tab,
		TabList,
		TabPanel,
		Tabs,
		GymSearch,
		Paper,
		Card,
		FilterBar,
		gymSearchResult,
		searchPressed,
		handleSearchPressed,
		$gymSearchResult
	});

	$$self.$inject_state = $$props => {
		if ("searchPressed" in $$props) $$invalidate(0, searchPressed = $$props.searchPressed);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$gymSearchResult*/ 2) {
			 console.log($gymSearchResult);
		}
	};

	return [searchPressed, $gymSearchResult, handleSearchPressed];
}

class Pages extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Pages",
			options,
			id: create_fragment$9.name
		});
	}
}

export default Pages;
//# sourceMappingURL=index-ff3da5f8.js.map
